<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving Systems with Monodromy · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../solving/">Solving Polynomial Systems</a></li><li class="current"><a class="toctext" href>Solving Systems with Monodromy</a><ul class="internal"><li><a class="toctext" href="#Strategies-1">Strategies</a></li><li><a class="toctext" href="#GroupActions-1">GroupActions</a></li><li><a class="toctext" href="#Helper-functions-1">Helper functions</a></li></ul></li><li><a class="toctext" href="../path_tracker/">Path tracker</a></li><li><a class="toctext" href="../newton/">Newton&#39;s method</a></li><li><a class="toctext" href="../sorting/">Sorting arrays of solutions</a></li><li><a class="toctext" href="../norms_distances/">Norms and Distances</a></li><li><a class="toctext" href="../systems/">Data structures for polynomial systems</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../predictors-correctors/">Predictors and Correctors</a></li><li><a class="toctext" href="../core_tracker/">Core tracker</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solving Systems with Monodromy</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/monodromy.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solving Systems with Monodromy</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Monodromy-Solve-1" href="#Monodromy-Solve-1">Monodromy Solve</a></h1><p>Next to <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a>, HomotopyContinuation.jl provides the function <code>monodromy_solve</code>. Instead of taking a two systems <code>f</code> and <code>g</code> and tracking an array of start solutions from <code>f</code> to <code>g</code>, <code>monodromy_solve</code> takes as input a single system with parameters <code>p</code> and together with a start solution <code>s</code>. Then by tracking <code>s</code> around loops in the parameters <code>p</code>, <code>monodromy_solve</code> duplicates the solution until a stopping criterion is reached.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.monodromy_solve" href="#HomotopyContinuation.monodromy_solve"><code>HomotopyContinuation.monodromy_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">monodromy_solve(F, sols, p; parameters=..., options..., pathtrackerkwargs...)</code></pre><p>Solve a polynomial system <code>F(x;p)</code> with specified parameters and initial solutions <code>sols</code> by monodromy techniques. This makes loops in the parameter space of <code>F</code> to find new solutions.</p><p><strong>Options</strong></p><ul><li><code>target_solutions_count=nothing</code>: The computations are stopped if this number of solutions is reached.</li><li><code>done_callback=always_false</code>: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution <code>x</code> and the second one are all current solutions (including <code>x</code>). Return <code>true</code> if the compuation is done.</li><li><code>maximal_number_of_iterations_without_progress::Int=10</code>: The maximal number of iterations (i.e. loops generated) without any progress.</li><li><code>group_action=nothing</code>: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.</li><li><code>strategy</code>: The strategy used to create loops. If <code>F</code> only depends linearly on <code>p</code> this will be <a href="#HomotopyContinuation.Petal"><code>Petal</code></a>. Otherwise this will be <a href="#HomotopyContinuation.Triangle"><code>Triangle</code></a> with weights if <code>F</code> is a real system.</li><li><code>show_progress=true</code>: Enable a progress meter.</li><li><code>distance_function=euclidean_distance</code>: The distance function used for <a href="../sorting/#HomotopyContinuation.UniquePoints"><code>UniquePoints</code></a>.</li><li><code>identical_tol::Float64=1e-6</code>: The tolerance with which it is decided whether two solutions are identical.</li><li><code>group_actions=nothing</code>: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions <code>foo</code> and <code>bar</code> you can set <code>group_actions=[foo, bar]</code>. See <a href="#HomotopyContinuation.GroupActions"><code>GroupActions</code></a> for details regarding the application rules.</li><li><code>group_action_on_all_nodes=false</code>: By default the group_action(s) are only applied on the solutions with the main parameter <code>p</code>. If this is enabled then it is applied for every parameter <code>q</code>.</li><li><code>parameter_sampler=independent_normal</code>: A function taking the parameter <code>p</code> and returning a new random parameter <code>q</code>. By default each entry of the parameter vector is drawn independently from the univariate normal distribution.</li><li><code>equivalence_classes=true</code>: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.</li><li><code>check_startsolutions=true</code>: If <code>true</code>, we do a Newton step for each entry of <code>sols</code>for checking if it is a valid startsolutions. Solutions which are not valid are sorted out.</li><li><code>timeout=float(typemax(Int))</code>: The maximal number of <em>seconds</em> the computation is allowed to run.</li><li><code>minimal_number_of_solutions</code>: The minimal number of solutions before a stopping heuristic is applied. By default this is half of <code>target_solutions_count</code> if applicable otherwise 2.</li></ul></div></div></section><h2><a class="nav-anchor" id="Strategies-1" href="#Strategies-1">Strategies</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Triangle" href="#HomotopyContinuation.Triangle"><code>HomotopyContinuation.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Triangle(;useweights=true)</code></pre><p>A triangle is a loop consisting of the main node and two addtional nodes. If <code>weights</code> is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Petal" href="#HomotopyContinuation.Petal"><code>HomotopyContinuation.Petal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Petal()</code></pre><p>A petal is a loop consisting of the main node and one other node connected by two edges with different random weights.</p></div></div></section><h2><a class="nav-anchor" id="GroupActions-1" href="#GroupActions-1">GroupActions</a></h2><p>If there is a group acting on the solution set of the polynomial system this can provided with the <code>group_action</code> keyword for single group actions or with the <code>group_actions</code> keyword for compositions of group actions. These will be internally transformed into <code>GroupActions</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.GroupActions" href="#HomotopyContinuation.GroupActions"><code>HomotopyContinuation.GroupActions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GroupActions(actions::Function...)</code></pre><p>Store a bunch of group actions <code>(f1, f2, f3, ...)</code>. Each action has to return a tuple. The actions are applied in the following sense</p><ol><li>f1 is applied on the original solution <code>s</code></li><li>f2 is applied on <code>s</code> and the results of 1</li><li>f3 is applied on <code>s</code> and the results of 1) and 2)</li></ol><p>and so on</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f1(s) = (s * s,);

julia&gt; f2(s) = (2s, -s, 5s);

julia&gt; f3(s) = (s + 1,);

julia&gt; GroupActions(f1)(3)
(3, 9)

julia&gt; GroupActions(f1, f2)(3)
(3, 9, 6, -3, 15, 18, -9, 45)

julia&gt; GroupActions(f1,f2, f3)(3)
(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)</code></pre></div></div></section><p>To help with the more common group actions we provide some helper functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.SymmetricGroup" href="#HomotopyContinuation.SymmetricGroup"><code>HomotopyContinuation.SymmetricGroup</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SymmetricGroup(n)</code></pre><p>Group action of the symmetric group S(n).</p></div></div></section><h2><a class="nav-anchor" id="Helper-functions-1" href="#Helper-functions-1">Helper functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.parameters" href="#HomotopyContinuation.parameters"><code>HomotopyContinuation.parameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parameters(r::MonodromyResult)</code></pre><p>Return the parameters corresponding to the given result <code>r</code>.</p></div></div></section><footer><hr/><a class="previous" href="../solving/"><span class="direction">Previous</span><span class="title">Solving Polynomial Systems</span></a><a class="next" href="../path_tracker/"><span class="direction">Next</span><span class="title">Path tracker</span></a></footer></article></body></html>
