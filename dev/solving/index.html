<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving Polynomial Systems · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Solving Polynomial Systems</a><ul class="internal"><li><a class="toctext" href="#solve-1">solve</a></li><li><a class="toctext" href="#Result-1">Result</a></li></ul></li><li><a class="toctext" href="../monodromy/">Solving Systems with Monodromy</a></li><li><a class="toctext" href="../path_tracker/">Path tracker</a></li><li><a class="toctext" href="../newton/">Newton&#39;s method</a></li><li><a class="toctext" href="../sorting/">Sorting arrays of solutions</a></li><li><a class="toctext" href="../norms_distances/">Norms and Distances</a></li><li><a class="toctext" href="../systems/">Data structures for polynomial systems</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../predictors-correctors/">Predictors and Correctors</a></li><li><a class="toctext" href="../core_tracker/">Core tracker</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solving Polynomial Systems</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/solving.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solving Polynomial Systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solving-Polynomial-Systems-1" href="#Solving-Polynomial-Systems-1">Solving Polynomial Systems</a></h1><h2><a class="nav-anchor" id="solve-1" href="#solve-1">solve</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solve" href="#HomotopyContinuation.solve"><code>HomotopyContinuation.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(args...; options...)::Result</code></pre><p>The solve function takes many different arguments and options depending on your specific situation, but in the it always returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a> containing the result of the computations. In the following we show the different inputs <code>solve</code> takes.</p><p><strong>Total Degree Homotopy</strong></p><pre><code class="language-none">solve(F; options...)</code></pre><p>Solve the system <code>F</code> using a total degree homotopy. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a>.</li><li><a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a> (the system has to represent a <strong>homogeneous</strong> polynomial system.)</li></ul><p>Additionally if <code>F</code> has a multi-homogenous structure you can provide variable groups to use a multi-homogenous totaldegree homotopy.</p><p><strong>Examples</strong></p><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1])
Result with 2 tracked paths
==================================
• 2 non-singular finite solutions (0 real)
• 0 singular finite solutions (0 real)
• 0 solutions at infinity
• 0 failed paths
• random seed: 448703</code></pre><p>If your polynomial system is already homogeneous, but you would like to consider it as an affine system you can do</p><pre><code class="language-julia">@polyvar x y z
solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)</code></pre><p>This yields the same result as <code>solve([x^2+y^2+1, 2x+3y-1])</code>.</p><p>By exploiting the multi-homogenous structure of a polynomial system it is possible to decrease the number of paths necessary to track.</p><pre><code class="language-julia">@polyvar x y
# Use variable groups to only track 2 paths instead of 4
solve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])</code></pre><p>To check whether a certain variable grouping is beneficial you can use the <a href="../reference/#HomotopyContinuation.bezout_number"><code>bezout_number</code></a> function.</p><p><strong>Start Target Homotopy</strong></p><pre><code class="language-none">solve(G, F, start_solutions; options...)</code></pre><p>This constructs the homotopy <span>$H(x,t) = tG(x)+(1-t)F(x)$</span> to compute solutions of the system <code>F</code>. <code>start_solutions</code> is a list of solutions of <code>G</code> which are tracked to solutions of <code>F</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">@polyvar x y
G = [x^2-1,y-1]
F = [x^2+y^2+z^2, 2x+3y-z]
solve(G, F, [[1, 1], [-1, 1]])</code></pre><p><strong>Parameter Homotopy</strong></p><pre><code class="language-none">solve(F, startsolutions; parameters, p₁, p₀, γ₁=nothing, γ₀=nothing)</code></pre><p>Solve the parameter homotopy</p><div>\[H(x, t) = F(x, (tγ₁p₁+(1-t)γ₀p₀) / (tγ₁+(1-t)γ₀)),\]</div><p>where <code>p₁</code> and <code>p₀</code> are a vector of parameter values for <span>$F$</span> and <code>γ₁</code> and <code>γ₀</code> are complex numbers. If <code>γ₁</code> or <code>γ₀</code> is <code>nothing</code>, it is assumed that <code>γ₁</code> and <code>γ₀</code> are <span>$1$</span>. The input <code>parameters</code> specifies the parameter variables of <code>F</code> which should be considered as parameters. Necessarily we have <code>length(parameters) == length(p₁) == length(p₀)</code>.</p><pre><code class="language-none">solve(F, startsolutions; parameters, startparameters, targetparameters, startgamma=nothing, targetgamma=nothing)</code></pre><p>This is a non-unicode variant where <code>γ₁=startparameters</code>, <code>γ₀=targetparameters</code>,     <code>γ₁=startgamma</code>, γ₀=<code>targetgamma</code>.</p><p><strong>Example</strong></p><p>We want to solve a parameter homotopy <span>$H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])$</span> where</p><div>\[F(x; a) := (x₁^2-a₁, x₁x₂-a₁+a₂)\]</div><p>and let&#39;s say we are only intersted in tracking of <span>$[1,1]$</span>. This can be accomplished as follows</p><pre><code class="language-julia">@polyvar x[1:2] a[1:2]
F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]
startsolutions = [[1, 1]]
solve(F, startsolutions; parameters=a, p₁=p₁, p₀=p₀)
# If you don&#39;t like unicode this is also possible
solve(F, startsolutions, parameters=a, startparameters=p₁, targetparameters=p₀)</code></pre><p><strong>Abstract Homotopy</strong></p><pre><code class="language-none">solve(H::AbstractHomotopy, start_solutions; options...)</code></pre><p>Solve the homotopy <code>H</code> by tracking the each solution of <span>$H(⋅, t)$</span> (as provided by <code>start_solutions</code>) from <span>$t=1$</span> to <span>$t=0$</span>. Note that <code>H</code> has to be a homotopy between <em>homogeneous</em> polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. <code>solve(H, startsolutions, homvar=3)</code> if the third variable is the homogenization variable.</p><p><strong>Options</strong></p><p>General options:</p><ul><li><code>seed::Int</code>: The random seed used during the computations.</li><li><code>report_progress=true</code>: Whether a progress bar should be printed to standard out.</li><li><code>threading=true</code>: Enable or disable multi-threading.</li><li><code>path_result_details=:default</code>: The amount of information computed in each path result. Possible values are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code> (all information possible).</li><li><code>homvar::Union{Int,MultivariatePolynomials.AbstractVariable}</code>: This considers the <em>homogeneous</em> system <code>F</code> as an affine system which was homogenized by <code>homvar</code>. If <code>F</code> is an <code>AbstractSystem</code> <code>homvar</code> is the index (i.e. <code>Int</code>) of the homogenization variable. If <code>F</code> is an <code>AbstractVariables</code> (e.g. created by <code>@polyvar x</code>) <code>homvar</code> is the actual variable used in the system <code>F</code>.</li><li><code>system::AbstractSystem</code>: A constructor to assemble a <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>. The default is <a href="../systems/#HomotopyContinuation.SPSystem"><code>SPSystem</code></a>. This constructor is only applied to the input of <code>solve</code>. The constructor is called with <code>system(polynomials, variables)</code> where <code>polynomials</code> is a vector of <code>MultivariatePolynomials.AbstractPolynomial</code>s and <code>variables</code> determines the variable ordering. If you experience significant compilation times, consider to change system to <code>FPSystem</code>.</li><li><code>homotopy::AbstractHomotopy</code>: A constructor to construct a <a href="../homotopies/#HomotopyContinuation.AbstractHomotopy"><code>AbstractHomotopy</code></a> for the totaldegree and start target homotopy. The default is <a href="../homotopies/#HomotopyContinuation.StraightLineHomotopy"><code>StraightLineHomotopy</code></a>. The constructor is called with <code>homotopy(start, target)</code> where <code>start</code> and <code>target</code> are homogeneous <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>s.</li><li><code>affine::Bool=false</code>: Indicate whether path tracking should happen in affine space rather than projective space. Currently this is only supported for parameter homotopies.</li></ul><p>Path tracking specific options:</p><ul><li><code>corrector::AbstractCorrector</code>: The corrector used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.NewtonCorrector"><code>NewtonCorrector</code></a>.</li><li><code>max_corrector_iters=3</code>: The maximal number of correction steps in a single step.</li><li><code>initial_step_size=0.1</code>: The step size of the first step.</li><li><code>max_steps=10_000</code>: The maximal number of iterations the path tracker has available.</li><li><code>min_step_size =1e-14</code>: The minimal step size.</li><li><code>max_step_size =Inf</code>: The maximal step size.</li><li><code>maximal_lost_digits::Real=-(log₁₀(eps) + 3)</code>: The tracking is terminated if we estimate that we loose more than <code>maximal_lost_digits</code> in the linear algebra steps.</li><li><code>predictor::AbstractPredictor</code>: The predictor used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.Heun"><code>Heun</code></a>()`.</li><li><code>max_refinement_iters=10</code>: The maximal number of correction steps used to refine the final value.</li><li><code>refinement_accuracy=1e-8</code>: The precision used to refine the final value.</li><li><code>accuracy=1e-7</code>: The precision used to track a value.</li><li><code>auto_scaling=true</code>: This only applies if we track in affine space. Automatically regauges the variables to effectively compute with a relative accuracy instead of an absolute one.</li></ul><p>Endgame specific options:</p><ul><li><code>at_infinity_check::Bool=true</code>: Whether the path tracker should stop paths going to infinity early.</li><li><code>max_step_size_endgame_start::Float64=1e-6</code>: The endgame only starts if the step size becomes smaller that the provided value.</li><li><code>samples_per_loop::Int=5</code>: To compute singular solutions Cauchy&#39;s integral formula is used. The accuracy of the solutions increases with the number of samples per loop.</li><li><code>max_winding_number::Int=12</code>: The maximal number of loops used in Cauchy&#39;s integral formula.</li><li><code>max_affine_norm::Float64=1e6</code>: A fallback heuristic to decide whether a path is going to infinity.</li><li><code>min_val_accuracy::Float64=0.001</code>: A tolerance used to decide whether we are in the endgame zone.</li></ul></div></div></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><p>A call to <a href="#HomotopyContinuation.solve"><code>solve</code></a> returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Result" href="#HomotopyContinuation.Result"><code>HomotopyContinuation.Result</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Result{V&lt;:AbstractVector}</code></pre><p>The result of <code>solve</code>. This is a wrapper around the results of each single path (<a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>) and it contains some additional informations like a random seed to replicate the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.seed" href="#HomotopyContinuation.seed"><code>HomotopyContinuation.seed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">seed(result)</code></pre><p>The random seed used in the computation.</p></div></div></section><p>In order to analyse a <code>Result</code> we provide the following helper functions</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.results" href="#HomotopyContinuation.results"><code>HomotopyContinuation.results</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">results(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, onlysigular=false, singulartol=1e14, onlyfinite=true)</code></pre><p>Return all <code>PathResult</code>s for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">R = solve(F)

# This gives us all PathResults considered non-singular and real (but still as a complex vector).
realsolutions = results(R, onlyreal=true, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.mapresults" href="#HomotopyContinuation.mapresults"><code>HomotopyContinuation.mapresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapresults(f::Function, result; conditions...)</code></pre><p>Apply the function <code>f</code> to all <code>PathResult</code>s for which the given conditions apply. For the possible conditions see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
realsolutions = mapresults(solution, R, onlyreal=true)</code></pre></div></div><div><div><pre><code class="language-none">mapresults(f, result::MonodromyResult; onlyreal=false, realtol=1e-6)</code></pre><p>Apply the function <code>f</code> to all entries of <code>MonodromyResult</code> for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
realsolutions = mapresults(solution, R, onlyreal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solutions" href="#HomotopyContinuation.solutions"><code>HomotopyContinuation.solutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solutions(result; conditions...)</code></pre><p>Return all solution (as <code>Vector</code>s) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; solutions(result)
[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]</code></pre></div></div><div><div><pre><code class="language-none">solutions(loop::Loop)</code></pre><p>Get the solutions of the loop.</p></div></div><div><div><pre><code class="language-none">solutions(result::MonodromyResult; onlyreal=false, realtol=1e-6)</code></pre><p>Return all solutions (as <code>SVector</code>s) for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">realsolutions = solutions(R, onlyreal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.realsolutions" href="#HomotopyContinuation.realsolutions"><code>HomotopyContinuation.realsolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">realsolutions(result; tol=1e-6, conditions...)</code></pre><p>Return all real solution (as <code>Vector</code>s of reals) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>. Note that <code>onlyreal</code> is always <code>true</code> and <code>realtol</code> is now <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; realsolutions(result)
[[2.0, -5.0], [-3.0, 0.0]]</code></pre></div></div><div><div><pre><code class="language-none">realsolutions(res::MonodromyResult; tol=1e-6)</code></pre><p>Returns the solutions of <code>res</code> whose imaginary part has norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.uniquesolutions" href="#HomotopyContinuation.uniquesolutions"><code>HomotopyContinuation.uniquesolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">uniquesolutions(R::Result; tol=1e-6, multiplicities=false, conditions...)</code></pre><p>Return all <em>unique</em> solutions. If <code>multiplicities</code> is <code>true</code>, then all <em>unique</em> solutions with their correspnding multiplicities as pairs <code>(s, m)</code> where <code>s</code> is the solution and <code>m</code> the multiplicity are returned. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @polyvar x;
julia&gt; uniquesolutions([(x-3)^3*(x+2)], multiplicities=true)
[([3.0+0.0im], 3), ([-2.0+0.0im], 1)]
julia&gt; uniquesolutions([(x-3)^3*(x+2)])
[[3.0+0.0im], [-2.0+0.0im]]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.finite" href="#HomotopyContinuation.finite"><code>HomotopyContinuation.finite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finite(result::AffineResults; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is finite. This is just a shorthand for <code>results(R; onlyfinite=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Union{Array{#s390,1} where #s390&lt;:PathResult, Result}}" href="#Base.real-Tuple{Union{Array{#s390,1} where #s390&lt;:PathResult, Result}}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">real(result, tol=1e-6)</code></pre><p>Get all results where the solutions are real with the given tolerance <code>tol</code>. See <a href="../path_tracker/#Base.isreal-Tuple{PathResult}"><code>isreal</code></a> for details regarding the determination of &#39;realness&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.atinfinity" href="#HomotopyContinuation.atinfinity"><code>HomotopyContinuation.atinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">atinfinity(result::AffineResult)</code></pre><p>Get all results where the solutions is at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.singular" href="#HomotopyContinuation.singular"><code>HomotopyContinuation.singular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">singular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is singular. This is just a shorthand for <code>results(R; onlysingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nonsingular" href="#HomotopyContinuation.nonsingular"><code>HomotopyContinuation.nonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nonsingular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is non-singular. This is just a shorthand for <code>results(R; onlynonsingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.failed" href="#HomotopyContinuation.failed"><code>HomotopyContinuation.failed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">failed(result)</code></pre><p>Get all results where the path tracking failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities-Tuple{Union{Array{#s390,1} where #s390&lt;:PathResult, Result}}" href="#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s390,1} where #s390&lt;:PathResult, Result}}"><code>HomotopyContinuation.multiplicities</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicities(V::Results; tol=1e-6)</code></pre><p>Returns a <code>Vector</code> of <code>Vector{PathResult}</code>s grouping the <code>PathResult</code>s whose solutions appear with multiplicities <em>greater</em> 1 in &#39;V&#39;. Two solutions are regarded as equal, when their pairwise distance is less than &#39;tol&#39;.</p></div></div></section><p>If you are interested in the number of solutions of a certain kind we also provide the following helper functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nresults" href="#HomotopyContinuation.nresults"><code>HomotopyContinuation.nresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nresults(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, singulartol=1e14, onlyfinite=true)</code></pre><p>The number of solutions which satisfy the corresponding predicates.</p><p><strong>Example</strong></p><pre><code class="language-julia">result = solve(F)
# Get all non-singular results where all imaginary parts are smaller than 1e-8
nresults(result, onlyreal=true, realtol=1e-8, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfinite" href="#HomotopyContinuation.nfinite"><code>HomotopyContinuation.nfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nfinite(affineresult)</code></pre><p>The number of finite solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nreal" href="#HomotopyContinuation.nreal"><code>HomotopyContinuation.nreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nreal(result; tol=1e-6)</code></pre><p>The number of real solutions where all imaginary parts of each solution are smaller than <code>tol</code>.</p></div></div><div><div><pre><code class="language-none">nreal(res::MonodromyResult; tol=1e-6)</code></pre><p>Counts how many solutions of <code>res</code> have imaginary part norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nsingular" href="#HomotopyContinuation.nsingular"><code>HomotopyContinuation.nsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nsingular(result; tol=1e10)</code></pre><p>The number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nnonsingular" href="#HomotopyContinuation.nnonsingular"><code>HomotopyContinuation.nnonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nnonsingular(result; tol=1e-10)</code></pre><p>The number of non-singular solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.natinfinity" href="#HomotopyContinuation.natinfinity"><code>HomotopyContinuation.natinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">natinfinity(result)</code></pre><p>The number of solutions at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfailed" href="#HomotopyContinuation.nfailed"><code>HomotopyContinuation.nfailed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nafailed(result)</code></pre><p>The number of failed paths.</p></div></div></section><p>Also make sure to check the documentation for <a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../monodromy/"><span class="direction">Next</span><span class="title">Solving Systems with Monodromy</span></a></footer></article></body></html>
