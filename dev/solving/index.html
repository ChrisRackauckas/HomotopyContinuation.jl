<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving general systems · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Solving general systems</a><ul class="internal"><li><a class="toctext" href="#Solve-1">Solve</a></li><li><a class="toctext" href="#Result-1">Result</a></li><li><a class="toctext" href="#Estimate-the-complexity-1">Estimate the complexity</a></li></ul></li><li><a class="toctext" href="../monodromy/">Solving parametrized systems with monodromy</a></li><li><a class="toctext" href="../path_tracker/">PathTracker</a></li><li><a class="toctext" href="../core_tracker/">CoreTracker</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../systems/">Polynomial systems</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solving general systems</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/solving.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solving general systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solving-general-polynomial-systems-1" href="#Solving-general-polynomial-systems-1">Solving general polynomial systems</a></h1><p>The <a href="#HomotopyContinuation.solve"><code>solve</code></a> function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our <a href="https://www.juliahomotopycontinuation.org/guides/introduction/">introduction</a> guide.</p><h2><a class="nav-anchor" id="Solve-1" href="#Solve-1">Solve</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solve" href="#HomotopyContinuation.solve"><code>HomotopyContinuation.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(args...; options...)::Result</code></pre><p>The solve function takes many different arguments and options depending on your specific situation, but in the end it always returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a> containing the result of the computations. Depending on the prodived arguments different kind of homotopies are constructed. In particular it is possible to construct the following homotopies:</p><ul><li>Total degree homotopy</li><li>Polyhedral homotopy</li><li>Parameter homotopy</li><li>Multi-homogenous homotopy</li><li>Start target homotopy</li></ul><p>If the input is a <em>homogenous</em> polynomial system, solutions in projective space are computed. Otherwise affine solutions are computed.</p><p><strong>Options</strong></p><p>The <code>solve</code> routines takes many different options. In particular all options to <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a> and <a href="../path_tracker/#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> are allowed. Additionally the following options are allowed:</p><ul><li><code>affine_tracking::Bool=true</code>: Indicate whether path tracking should happen in affine space.</li><li><code>early_stop_cb</code>: Here it is possible to provide a function (or any callable struct) which accepts a <code>PathResult</code> <code>r</code> as input and returns a <code>Bool</code>. If <code>early_stop_cb(r)</code> is <code>true</code> then no further paths are tracked and the computation is finished. This is only called for successfull paths unless <code>save_all_paths</code> is <code>true</code>. This is for example useful if you only want to compute one solution of a polynomial system. For this <code>early_stop_cb = _ -&gt; true</code> would be sufficient.</li><li><code>homotopy::AbstractHomotopy</code>: A constructor to construct a <a href="../homotopies/#HomotopyContinuation.AbstractHomotopy"><code>AbstractHomotopy</code></a> for the totaldegree and start target homotopy. The default is <a href="../homotopies/#HomotopyContinuation.StraightLineHomotopy"><code>StraightLineHomotopy</code></a>. The constructor is called with <code>homotopy(start, target)</code> where <code>start</code> and <code>target</code> are homogeneous <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>s.</li><li><code>homvar::Union{Int,MultivariatePolynomials.AbstractVariable}</code>: This considers the <em>homogeneous</em> system <code>F</code> as an affine system which was homogenized by <code>homvar</code>. If <code>F</code> is an <code>AbstractSystem</code> <code>homvar</code> is the index (i.e. <code>Int</code>) of the homogenization variable. If <code>F</code> is an <code>AbstractVariables</code> (e.g. created by <code>@polyvar x</code>) <code>homvar</code> is the actual variable used in the system <code>F</code>.</li><li><code>path_jumping_check::Bool=true</code>: Enable a check whether one of the paths jumped to another one.</li><li><code>path_result_details=:default</code>: The amount of information computed in each path result. Possible values are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code>.</li><li><code>projective_tracking::Bool=false</code>: Indicate whether path tracking should happen in projective space. The flag <code>affine_tracking</code> is dominant.</li><li><code>seed</code>: The random seed used during the computations. The seed is also reported in the result. For a given random seed the result is always identical.</li><li><code>show_progress</code> (default <code>true</code>): Whether a progress bar should be printed to report the progress of the current computation.</li><li><code>system::AbstractSystem</code>: A constructor to assemble a <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>. The default is <a href="../systems/#HomotopyContinuation.SPSystem"><code>SPSystem</code></a>. This constructor is only applied to the input of <code>solve</code>. The constructor is called with <code>system(polynomials, variables)</code> where <code>polynomials</code> is a vector of <code>MultivariatePolynomials.AbstractPolynomial</code>s and <code>variables</code> determines the variable ordering. If you experience significant compilation times, consider to change system to <code>FPSystem</code>.</li><li><code>system_scaling</code> (default <code>:equations</code>) Whether to apply an automatic scaling of the equations (:equations), of the equations and variables (<code>:equations_and_variables</code>) or no scaling at all (<code>nothing</code>).</li><li><code>threading</code> (default <code>true</code>): Enable or disable multi-threading. The number of threads used is controlled by the environment variable <code>JULIA_NUM_THREADS</code>.</li><li><code>variable_ordering</code>: Provide a custom ordering of the variables.</li></ul><p><strong>Examples</strong></p><p><strong>Total Degree Homotopy</strong></p><pre><code class="language-none">solve(F; options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the degrees of the entries of <code>F</code>. The number of paths to track is equal to the total degree <code>d₁⋯dⱼ</code>, where <code>dᵢ</code> is the degree of the <code>i</code>th entry of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by using the exported <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a></li><li>Any <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a></li></ul><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1])
Result with 2 solutions
==================================
• 2 non-singular solutions (0 real)
• 0 singular solutions (0 real)
• 2 paths tracked
• random seed: 661766</code></pre><p><strong>Polyhedral Homotopy</strong></p><pre><code class="language-none">solve(F; start_system = :polyhedral, only_torus=false, options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the Newton Polytopes of the ntries <code>F</code>. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of <code>F</code>. The mixed volume is at most the total degree of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a>. Note that the composition will not preserved.</li></ul><p>If <code>only_torus == true</code> then only solutions in the algebraic torus <span>$(ℂ\setminus \{0\})^n$</span> will be computed.</p><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral)
Result with 2 solutions
==================================
• 2 non-singular solutions (0 real)
• 0 singular solutions (0 real)
• 2 paths tracked
• random seed: 222880</code></pre><p><strong>Parameter Homotopy</strong></p><pre><code class="language-none">solve(F, startsolutions;
    parameters,
    start_parameters,
    target_parameters,
    start_gamma = nothing,
    target_gamma = nothing,
)</code></pre><p>Solve the parameter homotopy</p><div>\[H(x, t) = F(x, (tγ₁p₁+(1-t)γ₀p₀) / (tγ₁+(1-t)γ₀)),\]</div><p>where <span>$p₁$</span> (=<code>start_parameters</code>) and <span>$p₀$</span> (=<code>target_parameters</code>) are vectors of parameter values for <span>$F$</span> and <span>$γ₁$</span> (=<code>start_gamma</code>) and <span>$γ₀$</span> (=<code>target_gamma</code>)     are complex numbers. If <code>start_parameters</code> or <code>target_parameters</code> is <code>nothing</code>, it is assumed that <code>γ₁</code> and <code>γ₀</code> are <span>$1$</span>. The input <code>parameters</code> specifies the variables of <code>F</code> which should be considered as parameters. Necessarily we have <code>length(parameters) == length(p₁) == length(p₀)</code>.</p><pre><code class="language-none">solve(F, startsolutions; parameters, p₁, p₀, γ₁=nothing, γ₀=nothing)</code></pre><p>This is a unicode variant where <code>γ₁=start_parameters</code>, <code>γ₀=target_parameters</code>,     <code>γ₁=start_gamma</code>, γ₀=<code>target_gamma</code>.</p><p>We want to solve a parameter homotopy <span>$H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])$</span> where</p><div>\[F(x; a) := (x₁^2-a₁, x₁x₂-a₁+a₂)\]</div><p>and let&#39;s say we are only intersted in tracking of <span>$[1,1]$</span>. This can be accomplished as follows</p><pre><code class="language-julia">@polyvar x[1:2] a[1:2]
F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]
startsolutions = [[1, 1]]
p₁ = [1, 0]
p₀ = [3im, 0.5+2im]
solve(F, startsolutions; parameters=a, start_parameters=p₁, target_parameters=p₀)
# If you like unicode this is also possible
solve(F, startsolutions; parameters=a, p₁=p₁, p₀=p₀)</code></pre><p><strong>Start Target Homotopy</strong></p><pre><code class="language-none">solve(G, F, start_solutions; options...)</code></pre><p>This constructs the homotopy <span>$H(x,t) = tG(x)+(1-t)F(x)$</span> to compute solutions of the system <code>F</code>. <code>start_solutions</code> is a list of solutions of <code>G</code> which are tracked to solutions of <code>F</code>.</p><pre><code class="language-julia">@polyvar x y
G = [x^2-1,y-1]
F = [x^2+y^2+z^2, 2x+3y-z]
solve(G, F, [[1, 1], [-1, 1]])</code></pre><p><strong>Abstract Homotopy</strong></p><pre><code class="language-none">solve(H::AbstractHomotopy, start_solutions; options...)</code></pre><p>Solve the homotopy <code>H</code> by tracking the each solution of <span>$H(⋅, t)$</span> (as provided by <code>start_solutions</code>) from <span>$t=1$</span> to <span>$t=0$</span>. Note that <code>H</code> has to be a homotopy between <em>homogeneous</em> polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. <code>solve(H, startsolutions, homvar=3)</code> if the third variable is the homogenization variable.</p><p><strong>Homogeneous Systems</strong></p><p>If <code>F</code> has is homogeneous, we return results in projective space</p><pre><code class="language-julia">julia&gt; @polyvar x y z;
julia&gt; solve([x^2+y^2+z^2, 2x+3y-z])
Result{PVector{Complex{Float64},1}} with 2 solutions
====================================================
• 2 non-singular solutions (0 real)
• 0 singular solutions (0 real)
• 2 paths tracked
• random seed: 490575</code></pre><p>If your polynomial system is already homogeneous, but you would like to consider it as an affine system you can do</p><pre><code class="language-julia">@polyvar x y z
solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)</code></pre><p>This yields the same result as <code>solve([x^2+y^2+1, 2x+3y-1])</code>.</p><p><strong>Multi-homogeneous Systems</strong></p><p>By exploiting the multi-homogenous structure of a polynomial system it is possible to decrease the number of paths necessary to track.</p><pre><code class="language-julia">@polyvar x y
# Use variable groups to only track 2 paths instead of 4
solve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])</code></pre><p>To check whether a certain variable grouping is beneficial you can use the <a href="#HomotopyContinuation.bezout_number"><code>bezout_number</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Solver" href="#HomotopyContinuation.Solver"><code>HomotopyContinuation.Solver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Solver(pathtracker::PathTracker)</code></pre><p>A <code>Solver</code> is a wrapper around a given <code>pathtracker</code> to track multiple paths. It provides on top of the given <code>pathtracker</code> parallelization and an optional path jumping check. To construct a  <code>Solver</code> it is convenient to use the <a href="#HomotopyContinuation.solver"><code>solver</code></a> or <a href="#HomotopyContinuation.solver_startsolutions"><code>solver_startsolutions</code></a> functions. Given a solver one can use the <a href="#HomotopyContinuation.solve"><code>solve</code></a> function to solve a system. This struct is constructed for any call to <code>solve</code> unless already explicitly provided.</p><p><strong>Example</strong></p><p>Assume we want to solve a polynomial system repeatedly for many different values of the parameters <code>p</code>. The following example shows how to use a <code>Solver</code> to avoid some computational overhead compared to naively calling <a href="#HomotopyContinuation.solve"><code>solve</code></a>.</p><pre><code class="language-julia">@polyvar x y z p[1:3]
F = [
    x + 3 + 2y + 2 * y^2 - p[1],
    (x - 2 + 5y) * z + 4 - p[2] * z,
    (x + 2 + 4y) * z + 5 - p[3] * z,
]
q = randn(ComplexF64, 3)
S = solutions(solve(subs(F, p =&gt; q)))
# create some fake parameter values
params = [randn(3) for _ = 1:1000]
# create a `Solver` to reuse for the path tracking
F_solver = solver(F; parameters = p, generic_parameters = q)
# solve the system F for all paramaters p in params
params_solutions = map(params) do p
    solutions(solve(F_solver, S; target_parameters = p))
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solver" href="#HomotopyContinuation.solver"><code>HomotopyContinuation.solver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solver(args...; kwargs...)</code></pre><p>Create a [<code>Solver</code>]. Takes almost the same arguments as [<code>solve</code>].</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solver_startsolutions" href="#HomotopyContinuation.solver_startsolutions"><code>HomotopyContinuation.solver_startsolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solver_startsolutions(args...; kwargs...)</code></pre><p>Create a [<code>Solver</code>] and start solutions. Takes almost the same arguments as [<code>solve</code>].</p></div></div></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><p>A call to <a href="#HomotopyContinuation.solve"><code>solve</code></a> returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Result" href="#HomotopyContinuation.Result"><code>HomotopyContinuation.Result</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Result{V&lt;:AbstractVector}</code></pre><p>The result of <code>solve</code>. This is a wrapper around the results of each single path (<a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>) and it contains some additional informations like a random seed to replicate the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.seed" href="#HomotopyContinuation.seed"><code>HomotopyContinuation.seed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">seed(prob::AbstractProblem)</code></pre><p>Get the random seed used for the problem <code>prob</code>.</p></div></div><div><div><pre><code class="language-none">seed(result)</code></pre><p>The random seed used in the computation.</p></div></div></section><p>The nonsingular solutions are obtained as follows.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nonsingular" href="#HomotopyContinuation.nonsingular"><code>HomotopyContinuation.nonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nonsingular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is non-singular. This is just a shorthand for <code>results(R; only_nonsingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><p>The singular solutions are returned by using the following.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.singular" href="#HomotopyContinuation.singular"><code>HomotopyContinuation.singular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">singular(R::Results; tol=1e10, multiple_results=false, kwargs...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is singular. A solution is labeled singular if the condition number is greater than <code>singular_tol</code>, or if the winding number is &gt; 1. If <code>multiple_results=false</code> only one point from each cluster of multiple solutions is returned. If If <code>multiple_results=true</code> all singular solutions in <code>R</code> are returned. For the possible <code>kwargs</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><p>In order to analyse a <code>Result</code> we provide the following additional helper functions</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.results" href="#HomotopyContinuation.results"><code>HomotopyContinuation.results</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">results(result; only_real=false, real_tol=1e-6, only_nonsingular=false,
            onlysigular=false, singular_tol=1e10, onlyfinite=true, multiple_results=false)</code></pre><p>Return all <code>PathResult</code>s for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">R = solve(F)

# This gives us all PathResults considered non-singular and real (but still as a complex vector).
real_solutions = results(R, only_real=true, only_nonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.mapresults" href="#HomotopyContinuation.mapresults"><code>HomotopyContinuation.mapresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapresults(f::Function, result; conditions...)</code></pre><p>Apply the function <code>f</code> to all <code>PathResult</code>s for which the given conditions apply. For the possible conditions see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
real_solutions = mapresults(solution, R, only_real=true)</code></pre></div></div><div><div><pre><code class="language-none">mapresults(f, result::MonodromyResult; only_real=false, real_tol=1e-6)</code></pre><p>Apply the function <code>f</code> to all entries of <code>MonodromyResult</code> for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
real_solutions = mapresults(solution, R, only_real=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solutions" href="#HomotopyContinuation.solutions"><code>HomotopyContinuation.solutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solutions(result; conditions...)</code></pre><p>Return all solution (as <code>Vector</code>s) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; solutions(result)
[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]</code></pre></div></div><div><div><pre><code class="language-julia">solutions(result::MonodromyResult; only_real=false, real_tol=1e-6)</code></pre><p>Return all solutions (as <code>SVector</code>s) for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">real_solutions = solutions(R, only_real=true)</code></pre></div></div><div><div><pre><code class="language-none">solutions(MS::MonodromySolver)</code></pre><p>Get the solutions of the loop.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.real_solutions" href="#HomotopyContinuation.real_solutions"><code>HomotopyContinuation.real_solutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">real_solutions(result; tol=1e-6, conditions...)</code></pre><p>Return all real solution (as <code>Vector</code>s of reals) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>. Note that <code>only_real</code> is always <code>true</code> and <code>real_tol</code> is now <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; real_solutions(result)
[[2.0, -5.0], [-3.0, 0.0]]</code></pre></div></div><div><div><pre><code class="language-none">real_solutions(res::MonodromyResult; tol=1e-6)</code></pre><p>Returns the solutions of <code>res</code> whose imaginary part has norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.finite" href="#HomotopyContinuation.finite"><code>HomotopyContinuation.finite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finite(result::AffineResults; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is finite. This is just a shorthand for <code>results(R; onlyfinite=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Union{Array{#s409,1} where #s409&lt;:PathResult, Result}}" href="#Base.real-Tuple{Union{Array{#s409,1} where #s409&lt;:PathResult, Result}}"><code>Base.real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">real(result, tol=1e-6)</code></pre><p>Get all results where the solutions are real with the given tolerance <code>tol</code>. See <a href="../path_tracker/#HomotopyContinuation.is_real-Tuple{PathResult}"><code>is_real</code></a> for details regarding the determination of &#39;realness&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.at_infinity" href="#HomotopyContinuation.at_infinity"><code>HomotopyContinuation.at_infinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">at_infinity(result::AffineResult)</code></pre><p>Get all results where the solutions is at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.failed" href="#HomotopyContinuation.failed"><code>HomotopyContinuation.failed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">failed(result)</code></pre><p>Get all results where the path tracking failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities!-Tuple{Result}" href="#HomotopyContinuation.multiplicities!-Tuple{Result}"><code>HomotopyContinuation.multiplicities!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicities!(result::Result; tol=1e-6)</code></pre><p>Compute the multiplicities of the solutions in <code>result</code> with respect to the given tolerance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities-Tuple{Union{Array{#s409,1} where #s409&lt;:PathResult, Result}}" href="#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s409,1} where #s409&lt;:PathResult, Result}}"><code>HomotopyContinuation.multiplicities</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicities(V::Results; tol=1e-6)</code></pre><p>Returns a <code>Vector</code> of <code>Vector{PathResult}</code>s grouping the <code>PathResult</code>s whose solutions appear with multiplicities <em>greater</em> 1 in &#39;V&#39;. Two solutions are regarded as equal, when their pairwise distance is less than &#39;tol&#39;.</p></div></div></section><p>If you are interested in the number of solutions of a certain kind we also provide the following helper functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nresults" href="#HomotopyContinuation.nresults"><code>HomotopyContinuation.nresults</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nresults(
    result;
    only_real = false,
    real_tol = 1e-6,
    only_nonsingular = false,
    singular_tol = 1e10,
    onlyfinite = true,
)</code></pre><p>The number of solutions which satisfy the corresponding predicates.</p><p><strong>Example</strong></p><pre><code class="language-julia">result = solve(F)
# Get all non-singular results where all imaginary parts are smaller than 1e-8
nresults(result, only_real=true, real_tol=1e-8, only_nonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfinite" href="#HomotopyContinuation.nfinite"><code>HomotopyContinuation.nfinite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nfinite(result)</code></pre><p>The number of finite solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nreal" href="#HomotopyContinuation.nreal"><code>HomotopyContinuation.nreal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nreal(result; tol=1e-6)</code></pre><p>The number of real solutions where all imaginary parts of each solution are smaller than <code>tol</code>.</p></div></div><div><div><pre><code class="language-none">nreal(res::MonodromyResult; tol=1e-6)</code></pre><p>Counts how many solutions of <code>res</code> have imaginary part norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nsingular" href="#HomotopyContinuation.nsingular"><code>HomotopyContinuation.nsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nsingular(
    result;
    singular_tol = 1e10,
    multiplicitytol = 1e-5,
    counting_multiplicities = false,
    kwargs...,
)</code></pre><p>The number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than <code>tol</code>. If <code>counting_multiplicities=true</code> the number of singular solutions times their multiplicities is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nnonsingular" href="#HomotopyContinuation.nnonsingular"><code>HomotopyContinuation.nnonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nnonsingular(result; tol=1e-10)</code></pre><p>The number of non-singular solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nat_infinity" href="#HomotopyContinuation.nat_infinity"><code>HomotopyContinuation.nat_infinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nat_infinity(result)</code></pre><p>The number of solutions at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfailed" href="#HomotopyContinuation.nfailed"><code>HomotopyContinuation.nfailed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nafailed(result)</code></pre><p>The number of failed paths.</p></div></div></section><p>Also make sure to check the documentation for <a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><h2><a class="nav-anchor" id="Estimate-the-complexity-1" href="#Estimate-the-complexity-1">Estimate the complexity</a></h2><p>We provide methods to compute the maximal number of solutions of polynomial systems.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.bezout_number" href="#HomotopyContinuation.bezout_number"><code>HomotopyContinuation.bezout_number</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)
bezout_number(multidegrees, groups::VariableGroups)</code></pre><p>Compute the multi-homogeneous bezout number associated to the given system and variable groups.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.mixed_volume" href="#MixedSubdivisions.mixed_volume"><code>MixedSubdivisions.mixed_volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mixed_volume(F::Vector{&lt;:MP.AbstractPolynomialLike}; show_progress=true, algorithm=:regeneration)
mixed_volume(𝑨::Vector{&lt;:Matrix}; show_progress=true, algorithm=:regeneration)</code></pre><p>Compute the mixed volume of the given polynomial system <code>F</code> resp. represented by the support <code>𝑨</code>. There are two possible values for <code>algorithm</code>:</p><ul><li><code>:total_degree</code>: Use the total degree homotopy algorithm described in Section 7.1</li><li><code>:regeneration</code>: Use the tropical regeneration algorithm described in Section 7.2</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../monodromy/"><span class="direction">Next</span><span class="title">Solving parametrized systems with monodromy</span></a></footer></article></body></html>
