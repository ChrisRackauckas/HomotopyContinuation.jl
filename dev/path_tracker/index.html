<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PathTracker · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../solving/">Solving general systems</a></li><li><a class="toctext" href="../monodromy/">Solving paremeterized systems with monodromy</a></li><li><a class="toctext" href="../sorting/">Sorting arrays of solutions</a></li><li class="current"><a class="toctext" href>PathTracker</a><ul class="internal"><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#PathResult-1">PathResult</a></li></ul></li><li><a class="toctext" href="../core_tracker/">CoreTracker</a></li><li><a class="toctext" href="../newton/">Newton&#39;s method</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../predictors-correctors/">Predictors and correctors</a></li><li><a class="toctext" href="../systems/">Data structures for polynomial systems</a></li><li><a class="toctext" href="../norms_distances/">Norms and distances</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>PathTracker</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/path_tracker.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PathTracker</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-Tracker-1" href="#Path-Tracker-1">Path Tracker</a></h1><p>The <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> routine is only a very thin wrapper around <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>. Therefore you can also use <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> directly. This is for example a good choice if you have to solve the same problem many times.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathTracker" href="#HomotopyContinuation.PathTracker"><code>HomotopyContinuation.PathTracker</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia"> PathTracker{Prob&lt;:AbstractProblem, T, V&lt;:AbstractVector{T}, CT&lt;:CoreTracker}</code></pre><p><code>PathTracker</code> the way to track single paths. It combines the core path tracking routine with an endgame, i.e., it can also deal with singular solutions as well as diverging paths. We call a diverged path a path going to infinity. By convention a path is always tracked from t₁ &gt; 0 towards 0. During the path tracking an approximation of the valuation of a Puiseux series expansion of the solution is computed. This is used to decide whether a path is diverging. To compute singular solutions Cauchy&#39;s integral formula is used. There you have to trace out loops around the solution. The number of loops necessary to arrive back at the start point is called the <em>winding number</em>. In order to construct a <code>PathTracker</code> it is recommended to use the <a href="#HomotopyContinuation.pathtracker"><code>pathtracker</code></a> and <a href="#HomotopyContinuation.pathtracker_startsolutions"><code>pathtracker_startsolutions</code></a> helper functions. With a <code>PathTracker</code> constructed you can track a single path using the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> method. The result of this will be a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p><strong>Keyword arguments</strong></p><p><code>PathTracker</code> is a wrapper around <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a> and thus it is possible to set all options which are available for <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a>. There are the following <code>PathTracker</code> specific options:</p><p><strong>General endgame parameters</strong></p><ul><li><code>accuracy_eg::Float64=min(accuracy, 1e-5))</code>: It is possible to change the accuracy during the path tracking. Usually you want lower the accuracy.</li><li><code>cond_eg_start::Float64=1e4</code>: The endgame is only started if the condition of the Jacobian is larger than this threshold.</li><li><code>max_winding_number::Int=12</code>: This limits the maximal number of loops taken in applying Cauchy&#39;s formula.</li><li><code>min_cond_at_infinity::Float64=1e7</code>: A path is declared as going to infinity only if it&#39;s Jacobian is also larger than this threshold.</li><li><code>samples_per_loop::Int=12</code>: To compute singular solutions Cauchy&#39;s integral formula is used. The accuracy of the solutions increases with the number of samples per loop.</li><li><code>t_eg_start::Float64=0.1</code>: The endgame starts only if <code>t</code> is smaller than this threshold.</li><li><code>tol_val_inf_accurate::Float64=1e-4</code>: A valuation which would result in a path declared as going to infinity is only accepted if the estimated accuracy of the valuation is less than this threshold.</li><li><code>tol_val_finite_accurate::Float64=1e-3</code>: A valuation which would result in a proper solution is only accepted if the estimated accuracy of the valuation is less than this threshold. This is only affects solutions where the path has at some point near 0 a condition number larger than <code>cond_eg_start</code>.</li></ul><p><strong>Overdetermined system specific</strong></p><ul><li><code>overdetermined_min_accuracy=1e-5</code>: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.</li><li><code>overdetermined_min_residual=1e-3</code>: The minimal residual a singular solution needs to have to be considered a solution of the original system.</li></ul></div></div></section><p>The easiest way to construct a <code>PathTracker</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.pathtracker_startsolutions" href="#HomotopyContinuation.pathtracker_startsolutions"><code>HomotopyContinuation.pathtracker_startsolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pathtracker_startsolutions(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> and start solutions in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code>. This is convenient if you want to investigate single paths.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.pathtracker" href="#HomotopyContinuation.pathtracker"><code>HomotopyContinuation.pathtracker</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pathtracker(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code> with the exception that you do not need to specify startsolutions.</p><p><strong>Examples</strong></p><p><strong>Obtain single solution</strong></p><p>We want to construct a path tracker to track a parameterized system <code>f</code> with parameters <code>p</code> from the parameters <code>a</code> to <code>b</code>.</p><pre><code class="language-julia">tracker = pathtracker(f, parameters=p, p₁=a, p₀=b)</code></pre><p>You then can obtain a single solution at <code>b</code> by using</p><pre><code class="language-julia">x_b = solution(track(tracker, x_a))</code></pre></div></div></section><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><p>To track a single path you can use the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> and <a href="../core_tracker/#HomotopyContinuation.track!"><code>track!</code></a> methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.track" href="#HomotopyContinuation.track"><code>HomotopyContinuation.track</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">track(tracker::PathTracker, x₁, t₁::Float64=1.0; path_number::Int=1, details::Symbol=:default, options...)::PathResult</code></pre><p>Track the path with start solution <code>x₁</code> from <code>t₁</code> towards <code>t=0</code>. The <code>details</code> options controls the level of details of the informations available in the <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p>Possible values for the options are</p><ul><li><code>accuracy::Float64</code></li><li><code>max_corrector_iters::Int</code></li><li><code>max_steps::Int</code></li><li><code>start_parameters::AbstractVector</code></li><li><code>target_parameters::AbstractVector</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.track!" href="#HomotopyContinuation.track!"><code>HomotopyContinuation.track!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">track!(tracker::PathTracker, x₁, t₁::Float64=1.0; options...)::PathTrackerStatus.states</code></pre><p>Track the path with start solution <code>x₁</code> from <code>t₁</code> towards <code>t=0</code>.</p><p>Possible values for the options are</p><ul><li><code>accuracy::Float64</code></li><li><code>max_corrector_iters::Int</code></li><li><code>max_steps::Int</code></li><li><code>start_parameters::AbstractVector</code></li><li><code>target_parameters::AbstractVector</code></li></ul></div></div></section><p>The return type of <a href="../core_tracker/#HomotopyContinuation.track!"><code>track!</code></a> is</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathTrackerStatus.states" href="#HomotopyContinuation.PathTrackerStatus.states"><code>HomotopyContinuation.PathTrackerStatus.states</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PathTrackerStatus.states</code></pre><p>The possible return codes the path tracker can return are</p><ul><li><code>PathTrackerStatus.success</code></li><li><code>PathTrackerStatus.at_infinity</code></li><li><code>PathTrackerStatus.terminated_maximal_iterations</code></li><li><code>PathTrackerStatus.terminated_invalid_startvalue</code></li><li><code>PathTrackerStatus.terminated_step_size_too_small</code></li><li><code>PathTrackerStatus.terminated_singularity</code></li><li><code>PathTrackerStatus.terminated_ill_conditioned</code></li><li><code>PathTrackerStatus.terminated</code></li><li><code>PathTrackerStatus.post_check_failed</code></li><li><code>PathTrackerStatus.excess_solution</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L15">source</a></section><p>In the case that you track paths of parameter homotopy you can also change the parameters using</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.set_parameters!-Tuple{PathTracker}" href="#HomotopyContinuation.set_parameters!-Tuple{PathTracker}"><code>HomotopyContinuation.set_parameters!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_parameters!(tracker::PathTracker; start_parameters=nothing, target_parameters=nothing)</code></pre><p>Set the parameters of a parameter homotopy.</p></div></div></section><h2><a class="nav-anchor" id="PathResult-1" href="#PathResult-1">PathResult</a></h2><p>For each path we return a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a> containing the detailed information about the single path.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathResult" href="#HomotopyContinuation.PathResult"><code>HomotopyContinuation.PathResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PathResult{V&lt;:AbstractVector}</code></pre><p>A <code>PathResult</code> is the result of tracking of a path using <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>. Its fields are</p><ul><li><p><code>return_code</code>: One of <code>:success</code>, <code>:at_infinity</code> or any error code in <a href="#HomotopyContinuation.PathTrackerStatus.states"><code>PathTrackerStatus.states</code></a> converted to a <code>Symbol</code>.</p></li><li><p><code>solution::V</code>: The solution vector.</p></li><li><p><code>t::Float64</code>: The value of <code>t</code> at which <code>solution</code> was computed. Note that if <code>return_code</code> is <code>:at_infinity</code>, then <code>t</code> is the value when this was decided.</p></li><li><p><code>accuracy::Union{Nothing, Float64}</code>: An approximation of <span>$||x-x^*||₂$</span> where <span>$x$</span> is the computed solution and <span>$x^*$</span> is the true solution.</p></li><li><p><code>residual::Union{Nothing, Float64}</code>: The value of the 2-norm of <code>H(solution, 0)</code>.</p></li><li><p><code>condition_jacobian::Union{Nothing, Float64}</code>: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.</p></li><li><p><code>winding_number:Union{Nothing, Int}</code>: The estimated winding number. This is a lower bound on the multiplicity of the solution.</p></li><li><p><code>start_solution::Union{Nothing, Int}</code>: The start solution of the path.</p></li><li><p><code>accepted_steps::Int</code>: The number of accepted steps during the path tracking.</p></li><li><p><code>rejected_steps::Int</code>: The number of rejected steps during the path tracking.</p></li><li><p><code>valuation::Union{Nothing, Vector{Float64}}</code>: An approximation of the valuation of the Puiseux series expansion of <code>x(t)</code>.</p></li><li><p><code>valuation_accuracy::Union{Nothing, Vector{Float64}}</code>: An estimate of the accuracy of the valuation of the Puiseux series expansion of <code>x(t)</code>.</p><p>PathResult(tracker::PathTracker, start<em>solution=nothing, path</em>number::Union{Nothing,Int}=nothing; details=:default)</p></li></ul><p>Possible <code>details</code> values are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code> (all information possible).</p></div></div></section><p>The following helper functions are provided</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solution" href="#HomotopyContinuation.solution"><code>HomotopyContinuation.solution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solution(pathresult)</code></pre><p>Get the solution of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.accuracy-Tuple{PathResult}" href="#HomotopyContinuation.accuracy-Tuple{PathResult}"><code>HomotopyContinuation.accuracy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accuracy(pathresult)</code></pre><p>Get the accuracy of the solution <span>$x$</span> of the path, i.e., <span>$||H(x, 0)||₂$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.residual" href="#HomotopyContinuation.residual"><code>HomotopyContinuation.residual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">residual(pathresult)</code></pre><p>Get the residual of the solution <span>$x$</span> of the path, i.e., <span>$||H(x, 0)||₂$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.start_solution" href="#HomotopyContinuation.start_solution"><code>HomotopyContinuation.start_solution</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">start_solution(pathresult)</code></pre><p>Get the start solution of the solution <span>$x$</span> of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isreal-Tuple{PathResult}" href="#Base.isreal-Tuple{PathResult}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isreal(pathresult; tol=1e-6)</code></pre><p>We consider a result as <code>real</code> if the 2-norm of the imaginary part of the solution is at most <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.issuccess-Tuple{PathResult}" href="#LinearAlgebra.issuccess-Tuple{PathResult}"><code>LinearAlgebra.issuccess</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">issuccess(pathresult)</code></pre><p>Checks whether the path is successfull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isfailed" href="#HomotopyContinuation.isfailed"><code>HomotopyContinuation.isfailed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isfailed(pathresult)</code></pre><p>Checks whether the path failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isaffine" href="#HomotopyContinuation.isaffine"><code>HomotopyContinuation.isaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isaffine(pathresult)</code></pre><p>Return`s true if the solution is an affine vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isprojective" href="#HomotopyContinuation.isprojective"><code>HomotopyContinuation.isprojective</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isprojective(pathresult)</code></pre><p>Return`s true if the solution is a projective vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isatinfinity" href="#HomotopyContinuation.isatinfinity"><code>HomotopyContinuation.isatinfinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isatinfinity(pathresult)</code></pre><p>Checks whether the path goes to infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.issingular" href="#HomotopyContinuation.issingular"><code>HomotopyContinuation.issingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">issingular(pathresult; tol=1e10)</code></pre><p>Checks whether the path result is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.isnonsingular" href="#HomotopyContinuation.isnonsingular"><code>HomotopyContinuation.isnonsingular</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isnonsingular(pathresult; tol=1e10)</code></pre><p>Checks whether the path result is non-singular. This is true if it is not singular.</p></div></div></section><footer><hr/><a class="previous" href="../sorting/"><span class="direction">Previous</span><span class="title">Sorting arrays of solutions</span></a><a class="next" href="../core_tracker/"><span class="direction">Next</span><span class="title">CoreTracker</span></a></footer></article></body></html>
