var documenterSearchIndex = {"docs":
[{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for solving systems of polynomials equations with only finitely many solutions using numerical homotopy continuation. If this is your first time reading this documentation, we recommend you start with the getting started guide.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n  \"solving.md\",\n  \"monodromy.md\",\n  \"path_tracker.md\",\n  \"newton.md\",\n  \"sorting.md\",\n  \"norms_distances.md\",\n  \"systems.md\",\n  \"homotopies.md\",\n  \"predictors-correctors.md\",\n  \"core_tracker.md\",\n  \"reference.md\"]","category":"page"},{"location":"solving/#Solving-Polynomial-Systems-1","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"","category":"section"},{"location":"solving/#solve-1","page":"Solving Polynomial Systems","title":"solve","text":"","category":"section"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"solve","category":"page"},{"location":"solving/#HomotopyContinuation.solve","page":"Solving Polynomial Systems","title":"HomotopyContinuation.solve","text":"solve(args...; options...)::Result\n\nThe solve function takes many different arguments and options depending on your specific situation, but in the it always returns a Result containing the result of the computations. In the following we show the different inputs solve takes.\n\nTotal Degree Homotopy\n\nsolve(F; options...)\n\nSolve the system F using a start system computed from the degrees of the entries of F. The number of paths to track is equal to the total degree d1⋯dn, where di is the degree of the ith entry of F. F can be\n\nVector{<:MultivariatePolynomials.AbstractPolynomial} (e.g. constructed by @polyvar)\nA composition of polynomial systems constructed by compose.\nAbstractSystem (the system has to represent a homogeneous polynomial system.)\n\nExample\n\nWe can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way:\n\njulia> @polyvar x y;\njulia> solve([x^2+y^2+1, 2x+3y-1])\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 661766\n\n\n# Polyhedral Homotopy\n\n    solve(F; start_system = :polyhedral, options...)\n\nSolve the system `F` using a start system computed from the Newton Polytopes of the entries `F`. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of `F`. The mixed volume is at most the total degree of `F`. `F` can be\n- `Vector{<:MultivariatePolynomials.AbstractPolynomial}` (e.g. constructed by `@polyvar`)\n- A composition of polynomial systems constructed by [`compose`](@ref).\n- [`AbstractSystem`](@ref) (the system has to represent a **homogeneous** polynomial system.)\nsolve(f; start_system = :polyhedral, affine_tracking=true, seed = 141691, save_all_paths = true)\n\n### Example\nWe can solve the system ``F(x,y) = (x^2+y^2+1, 2x+3y-1)`` in the following way:\n\njulia julia> @polyvar x y; julia> solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral) Result with 2 solutions ================================== • 2 non-singular solutions (0 real) • 0 singular solutions (0 real) • 2 paths tracked • random seed: 222880\n\nHomogeneous Systems\n\nIf F has is homogeneous, we return results in projective space\n\nExamples\n\njulia> @polyvar x y z;\njulia> solve([x^2+y^2+z^2, 2x+3y-z])\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 291729\n\nIf your polynomial system is already homogeneous, but you would like to consider it as an affine system you can do\n\n@polyvar x y z\nsolve([x^2+y^2+z^2, 2x+3y-z], homvar=z)\n\nThis yields the same result as solve([x^2+y^2+1, 2x+3y-1]).\n\nMultihomogeneous Systems\n\nBy exploiting the multi-homogenous structure of a polynomial system it is possible to decrease the number of paths necessary to track.\n\n@polyvar x y\n# Use variable groups to only track 2 paths instead of 4\nsolve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])\n\nTo check whether a certain variable grouping is beneficial you can use the bezout_number function.\n\nStart Target Homotopy\n\nsolve(G, F, start_solutions; options...)\n\nThis constructs the homotopy H(xt) = tG(x)+(1-t)F(x) to compute solutions of the system F. start_solutions is a list of solutions of G which are tracked to solutions of F.\n\nExample\n\n@polyvar x y\nG = [x^2-1,y-1]\nF = [x^2+y^2+z^2, 2x+3y-z]\nsolve(G, F, [[1, 1], [-1, 1]])\n\nParameter Homotopy\n\nsolve(F, startsolutions; parameters, start_parameters, target_parameters, start_gamma=nothing, target_gamma=nothing)\n\nSolve the parameter homotopy\n\nH(x t) = F(x (tγ₁p₁+(1-t)γ₀p₀)  (tγ₁+(1-t)γ₀))\n\nwhere p₁ (=start_parameters) and p₀ (=target_parameters) are vectors of parameter values for F and γ₁ (=start_gamma) and γ₀ (=target_gamma) are complex numbers. If start_parameters or target_parameters is nothing, it is assumed that γ₁ and γ₀ are 1. The input parameters specifies the variables of F which should be considered as parameters. Necessarily we have length(parameters) == length(p₁) == length(p₀).\n\nsolve(F, startsolutions; parameters, p₁, p₀, γ₁=nothing, γ₀=nothing)\n\nThis is a unicode variant where γ₁=start_parameters, γ₀=target_parameters,     γ₁=start_gamma, γ₀=target_gamma.\n\nExample\n\nWe want to solve a parameter homotopy H(xt) = F(x t1 0+(1-t)2 4) where\n\nF(x a) = (x₁^2-a₁ x₁x₂-a₁+a₂)\n\nand let's say we are only intersted in tracking of 11. This can be accomplished as follows\n\n@polyvar x[1:2] a[1:2]\nF = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]\nstartsolutions = [[1, 1]]\np₁ = [1, 0]\np₀ = [3im, 0.5+2im]\nsolve(F, startsolutions; parameters=a, start_parameters=p₁, target_parameters=p₀)\n# If you like unicode this is also possible\nsolve(F, startsolutions; parameters=a, p₁=p₁, p₀=p₀)\n\nAbstract Homotopy\n\nsolve(H::AbstractHomotopy, start_solutions; options...)\n\nSolve the homotopy H by tracking the each solution of H( t) (as provided by start_solutions) from t=1 to t=0. Note that H has to be a homotopy between homogeneous polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. solve(H, startsolutions, homvar=3) if the third variable is the homogenization variable.\n\nOptions\n\nGeneral options:\n\nseed::Int: The random seed used during the computations.\nshow_progress=true: Whether a progress bar should be printed to standard out.\nthreading=true: Enable or disable multi-threading.\npath_result_details=:default: The amount of information computed in each path result. Possible values are :minimal (minimal details), :default (default) and :extensive (all information possible).\nhomvar::Union{Int,MultivariatePolynomials.AbstractVariable}: This considers the homogeneous system F as an affine system which was homogenized by homvar. If F is an AbstractSystem homvar is the index (i.e. Int) of the homogenization variable. If F is an AbstractVariables (e.g. created by @polyvar x) homvar is the actual variable used in the system F.\nsystem::AbstractSystem: A constructor to assemble a AbstractSystem. The default is SPSystem. This constructor is only applied to the input of solve. The constructor is called with system(polynomials, variables) where polynomials is a vector of MultivariatePolynomials.AbstractPolynomials and variables determines the variable ordering. If you experience significant compilation times, consider to change system to FPSystem.\nhomotopy::AbstractHomotopy: A constructor to construct a AbstractHomotopy for the totaldegree and start target homotopy. The default is StraightLineHomotopy. The constructor is called with homotopy(start, target) where start and target are homogeneous AbstractSystems.\naffine_tracking::Bool=false: Indicate whether path tracking should happen in affine space rather than projective space. Currently this is only supported for parameter homotopies.\npath_jumping_check::Bool=true: Enable a check whether one of the paths jumped to another one.\n\nPath tracking specific options:\n\ncorrector::AbstractCorrector: The corrector used during in the predictor-corrector scheme. The default is NewtonCorrector.\nmax_corrector_iters=3: The maximal number of correction steps in a single step.\ninitial_step_size=0.1: The step size of the first step.\nmax_steps=1_000: The maximal number of iterations the path tracker has available.\nmin_step_size=1e-14: The minimal step size.\nmax_step_size=Inf: The maximal step size.\nmaximal_lost_digits::Real=-(log₁₀(eps) + 3): The tracking is terminated if we estimate that we loose more than maximal_lost_digits in the linear algebra steps.\npredictor::AbstractPredictor: The predictor used during in the predictor-corrector scheme. The default is Heun()`.\nmax_refinement_iters=10: The maximal number of correction steps used to refine the final value.\nrefinement_accuracy=1e-8: The precision used to refine the final value.\naccuracy=1e-7: The precision used to track a value.\nauto_scaling=true: This only applies if we track in affine space. Automatically regauges the variables to effectively compute with a relative accuracy instead of an absolute one.\noverdetermined_min_accuracy=1e-5: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.\noverdetermined_min_residual=1e-3: The minimal residual a singular solution needs to have to be considered a solution of the original system.\n\nEndgame specific options:\n\nat_infinity_check::Bool=true: Whether the path tracker should stop paths going to infinity early.\nmin_step_size_endgame_start=1e-10: The endgame only starts if the step size becomes smaller that the provided value.\nsamples_per_loop::Int=5: To compute singular solutions Cauchy's integral formula is used. The accuracy of the solutions increases with the number of samples per loop.\nmax_winding_number::Int=12: The maximal number of loops used in Cauchy's integral formula.\nmax_affine_norm::Float64=1e6: A fallback heuristic to decide whether a path is going to infinity.\nmin_val_accuracy::Float64=0.001: A tolerance used to decide whether we are in the endgame zone.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Result-1","page":"Solving Polynomial Systems","title":"Result","text":"","category":"section"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"A call to solve returns a Result:","category":"page"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"Result\nseed","category":"page"},{"location":"solving/#HomotopyContinuation.Result","page":"Solving Polynomial Systems","title":"HomotopyContinuation.Result","text":"Result{V<:AbstractVector}\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional informations like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"solving/#HomotopyContinuation.seed","page":"Solving Polynomial Systems","title":"HomotopyContinuation.seed","text":"seed(result)\n\nThe random seed used in the computation.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"In order to analyse a Result we provide the following helper functions","category":"page"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"results\nmapresults\nsolutions\nrealsolutions\nuniquesolutions\nfinite\nBase.real(::HomotopyContinuation.Results)\natinfinity\nsingular\nnonsingular\nfailed\nmultiplicities(::HomotopyContinuation.Results)","category":"page"},{"location":"solving/#HomotopyContinuation.results","page":"Solving Polynomial Systems","title":"HomotopyContinuation.results","text":"results(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, onlysigular=false, singulartol=1e10, onlyfinite=true)\n\nReturn all PathResults for which the given conditions apply.\n\nExample\n\nR = solve(F)\n\n# This gives us all PathResults considered non-singular and real (but still as a complex vector).\nrealsolutions = results(R, onlyreal=true, onlynonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.mapresults","page":"Solving Polynomial Systems","title":"HomotopyContinuation.mapresults","text":"mapresults(f::Function, result; conditions...)\n\nApply the function f to all PathResults for which the given conditions apply. For the possible conditions see results.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nrealsolutions = mapresults(solution, R, onlyreal=true)\n\n\n\n\n\nmapresults(f, result::MonodromyResult; onlyreal=false, realtol=1e-6)\n\nApply the function f to all entries of MonodromyResult for which the given conditions apply.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nrealsolutions = mapresults(solution, R, onlyreal=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.solutions","page":"Solving Polynomial Systems","title":"HomotopyContinuation.solutions","text":"solutions(result; conditions...)\n\nReturn all solution (as Vectors) for which the given conditions apply. For the possible conditions see results.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> solutions(result)\n[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]\n\n\n\n\n\nsolutions(loop::Loop)\n\nGet the solutions of the loop.\n\n\n\n\n\nsolutions(result::MonodromyResult; onlyreal=false, realtol=1e-6)\n\nReturn all solutions (as SVectors) for which the given conditions apply.\n\nExample\n\nrealsolutions = solutions(R, onlyreal=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.realsolutions","page":"Solving Polynomial Systems","title":"HomotopyContinuation.realsolutions","text":"realsolutions(result; tol=1e-6, conditions...)\n\nReturn all real solution (as Vectors of reals) for which the given conditions apply. For the possible conditions see results. Note that onlyreal is always true and realtol is now tol.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> realsolutions(result)\n[[2.0, -5.0], [-3.0, 0.0]]\n\n\n\n\n\nrealsolutions(res::MonodromyResult; tol=1e-6)\n\nReturns the solutions of res whose imaginary part has norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.uniquesolutions","page":"Solving Polynomial Systems","title":"HomotopyContinuation.uniquesolutions","text":"uniquesolutions(R::Result; tol=1e-6, multiplicities=false, conditions...)\n\nReturn all unique solutions. If multiplicities is true, then all unique solutions with their correspnding multiplicities as pairs (s, m) where s is the solution and m the multiplicity are returned. For the possible conditions see results.\n\nExample\n\njulia> @polyvar x;\njulia> uniquesolutions([(x-3)^3*(x+2)], multiplicities=true)\n[([3.0+0.0im], 3), ([-2.0+0.0im], 1)]\njulia> uniquesolutions([(x-3)^3*(x+2)])\n[[3.0+0.0im], [-2.0+0.0im]]\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.finite","page":"Solving Polynomial Systems","title":"HomotopyContinuation.finite","text":"finite(result::AffineResults; conditions...)\n\nReturn all PathResults for which the solution is finite. This is just a shorthand for results(R; onlyfinite=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Base.real-Tuple{Union{Array{#s484,1} where #s484<:PathResult, Result}}","page":"Solving Polynomial Systems","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See isreal for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#HomotopyContinuation.atinfinity","page":"Solving Polynomial Systems","title":"HomotopyContinuation.atinfinity","text":"atinfinity(result::AffineResult)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.singular","page":"Solving Polynomial Systems","title":"HomotopyContinuation.singular","text":"singular(result::Results; conditions...)\n\nReturn all PathResults for which the solution is singular. This is just a shorthand for results(R; onlysingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nonsingular","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nonsingular","text":"nonsingular(result::Results; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; onlynonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.failed","page":"Solving Polynomial Systems","title":"HomotopyContinuation.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s484,1} where #s484<:PathResult, Result}}","page":"Solving Polynomial Systems","title":"HomotopyContinuation.multiplicities","text":"multiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"If you are interested in the number of solutions of a certain kind we also provide the following helper functions.","category":"page"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"nresults\nnfinite\nnreal\nnsingular\nnnonsingular\nnatinfinity\nnfailed","category":"page"},{"location":"solving/#HomotopyContinuation.nresults","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nresults","text":"nresults(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, singulartol=1e10, onlyfinite=true)\n\nThe number of solutions which satisfy the corresponding predicates.\n\nExample\n\nresult = solve(F)\n# Get all non-singular results where all imaginary parts are smaller than 1e-8\nnresults(result, onlyreal=true, realtol=1e-8, onlynonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfinite","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nfinite","text":"nfinite(result)\n\nThe number of finite solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nreal","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions where all imaginary parts of each solution are smaller than tol.\n\n\n\n\n\nnreal(res::MonodromyResult; tol=1e-6)\n\nCounts how many solutions of res have imaginary part norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nsingular","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nsingular","text":"nsingular(result; tol=1e10)\n\nThe number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than tol.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nnonsingular","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nnonsingular","text":"nnonsingular(result; tol=1e-10)\n\nThe number of non-singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.natinfinity","page":"Solving Polynomial Systems","title":"HomotopyContinuation.natinfinity","text":"natinfinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfailed","page":"Solving Polynomial Systems","title":"HomotopyContinuation.nfailed","text":"nafailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving Polynomial Systems","title":"Solving Polynomial Systems","text":"Also make sure to check the documentation for PathResult.","category":"page"},{"location":"monodromy/#Monodromy-Solve-1","page":"Solving Systems with Monodromy","title":"Monodromy Solve","text":"","category":"section"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"Next to solve, HomotopyContinuation.jl provides the function monodromy_solve. Instead of taking a two systems f and g and tracking an array of start solutions from f to g, monodromy_solve takes as input a single system with parameters p and together with a start solution s. Then by tracking s around loops in the parameters p, monodromy_solve duplicates the solution until a stopping criterion is reached.","category":"page"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"monodromy_solve","category":"page"},{"location":"monodromy/#HomotopyContinuation.monodromy_solve","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.monodromy_solve","text":"monodromy_solve(F, sols, p; parameters=..., options..., pathtrackerkwargs...)\n\nSolve a polynomial system F(x;p) with specified parameters and initial solutions sols by monodromy techniques. This makes loops in the parameter space of F to find new solutions.\n\nOptions\n\ntarget_solutions_count=nothing: The computations are stopped if this number of solutions is reached.\ndone_callback=always_false: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution x and the second one are all current solutions (including x). Return true if the compuation is done.\nmaximal_number_of_iterations_without_progress::Int=10: The maximal number of iterations (i.e. loops generated) without any progress.\ngroup_action=nothing: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.\nstrategy: The strategy used to create loops. If F only depends linearly on p this will be Petal. Otherwise this will be Triangle with weights if F is a real system.\nshow_progress=true: Enable a progress meter.\ndistance_function=euclidean_distance: The distance function used for UniquePoints.\nidentical_tol::Float64=1e-6: The tolerance with which it is decided whether two solutions are identical.\ngroup_actions=nothing: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions foo and bar you can set group_actions=[foo, bar]. See GroupActions for details regarding the application rules.\ngroup_action_on_all_nodes=false: By default the group_action(s) are only applied on the solutions with the main parameter p. If this is enabled then it is applied for every parameter q.\nparameter_sampler=independent_normal: A function taking the parameter p and returning a new random parameter q. By default each entry of the parameter vector is drawn independently from the univariate normal distribution.\nequivalence_classes=true: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.\ncheck_startsolutions=true: If true, we do a Newton step for each entry of solsfor checking if it is a valid startsolutions. Solutions which are not valid are sorted out.\ntimeout=float(typemax(Int)): The maximal number of seconds the computation is allowed to run.\nminimal_number_of_solutions: The minimal number of solutions before a stopping heuristic is applied. By default this is half of target_solutions_count if applicable otherwise 2.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Strategies-1","page":"Solving Systems with Monodromy","title":"Strategies","text":"","category":"section"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"Triangle\nPetal","category":"page"},{"location":"monodromy/#HomotopyContinuation.Triangle","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.Triangle","text":"Triangle(;useweights=true)\n\nA triangle is a loop consisting of the main node and two addtional nodes. If weights is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.Petal","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.Petal","text":"Petal()\n\nA petal is a loop consisting of the main node and one other node connected by two edges with different random weights.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#GroupActions-1","page":"Solving Systems with Monodromy","title":"GroupActions","text":"","category":"section"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"If there is a group acting on the solution set of the polynomial system this can provided with the group_action keyword for single group actions or with the group_actions keyword for compositions of group actions. These will be internally transformed into GroupActions.","category":"page"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"GroupActions","category":"page"},{"location":"monodromy/#HomotopyContinuation.GroupActions","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.GroupActions","text":"GroupActions(actions::Function...)\n\nStore a bunch of group actions (f1, f2, f3, ...). Each action has to return a tuple. The actions are applied in the following sense\n\nf1 is applied on the original solution s\nf2 is applied on s and the results of 1\nf3 is applied on s and the results of 1) and 2)\n\nand so on\n\nExample\n\njulia> f1(s) = (s * s,);\n\njulia> f2(s) = (2s, -s, 5s);\n\njulia> f3(s) = (s + 1,);\n\njulia> GroupActions(f1)(3)\n(3, 9)\n\njulia> GroupActions(f1, f2)(3)\n(3, 9, 6, -3, 15, 18, -9, 45)\n\njulia> GroupActions(f1,f2, f3)(3)\n(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"To help with the more common group actions we provide some helper functions:","category":"page"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"SymmetricGroup","category":"page"},{"location":"monodromy/#HomotopyContinuation.SymmetricGroup","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.SymmetricGroup","text":"SymmetricGroup(n)\n\nGroup action of the symmetric group S(n).\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#Helper-functions-1","page":"Solving Systems with Monodromy","title":"Helper functions","text":"","category":"section"},{"location":"monodromy/#","page":"Solving Systems with Monodromy","title":"Solving Systems with Monodromy","text":"parameters","category":"page"},{"location":"monodromy/#HomotopyContinuation.parameters","page":"Solving Systems with Monodromy","title":"HomotopyContinuation.parameters","text":"parameters(r::MonodromyResult)\n\nReturn the parameters corresponding to the given result r.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#Path-Tracker-1","page":"Path tracker","title":"Path Tracker","text":"","category":"section"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"The solve routine is only a very thin wrapper around PathTracker. Therefore you can also use PathTracker directly. This is for example a good choice if you have to solve the same problem many times.","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"PathTracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTracker","page":"Path tracker","title":"HomotopyContinuation.PathTracker","text":" PathTracker{Prob<:AbstractProblem, T, V<:AbstractVector{T}, CT<:CoreTracker}\n\nPathTracker the way to track single paths. It combines the core path tracking routine with an endgame, i.e., it can also deal with singular solutions as well as paths going to infinity. PathTracker is a wrapper around CoreTracker and thus has all configuration possibilities CoreTracker has.\n\nThere are the following PathTracker specific options (with their defaults in parens):\n\nat_infinity_check::Bool=true: Whether the path tracker should stop paths going to infinity early.\nmin_step_size_endgame_start=1e-10: The endgame only starts if the step size becomes smaller that the provided value.\nsamples_per_loop::Int=5: To compute singular solutions Cauchy's integral formula is used. The accuracy of the solutions increases with the number of samples per loop.\nmax_winding_number::Int=12: The maximal number of loops used in Cauchy's integral formula.\nmax_affine_norm::Float64=1e6: A fallback heuristic to decide whether a path is going to infinity.\nmin_val_accuracy::Float64=0.001: A tolerance used to decide whether we are in the endgame zone.\noverdetermined_min_accuracy=1e-5: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.\noverdetermined_min_residual=1e-3: The minimal residual a singular solution needs to have to be considered a solution of the original system.\n\nIn order to construct a pathtracker it is recommended to use the pathtracker and pathtracker_startsolutions helper functions.\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"The easiest way to construct a PathTracker:","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"pathtracker_startsolutions\npathtracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.pathtracker_startsolutions","page":"Path tracker","title":"HomotopyContinuation.pathtracker_startsolutions","text":"pathtracker_startsolutions(args...; kwargs...)\n\nConstruct a PathTracker and start solutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.pathtracker","page":"Path tracker","title":"HomotopyContinuation.pathtracker","text":"pathtracker(args...; kwargs...)\n\nConstruct a PathTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parameterized system f with parameters p from the parameters a to b.\n\ntracker = pathtracker(f, parameters=p, p₁=a, p₀=b)\n\nYou then can obtain a single solution at b by using\n\nx_b = solution(track(tracker, x_a))\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#Methods-1","page":"Path tracker","title":"Methods","text":"","category":"section"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"To track a single path you can use the track and track! methods.","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"track(tracker::PathTracker, x₁, t₁::Float64=1.0; path_number::Int=1, details::Symbol=:default, kwargs...)\ntrack!(tracker::PathTracker, x₁, t₁::Float64=1.0; kwargs...)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.track","page":"Path tracker","title":"HomotopyContinuation.track","text":"track(tracker::PathTracker, x₁, t₁::Float64=1.0; path_number::Int=1, details::Symbol=:default, options...)::PathResult\n\nTrack the path with start solution x₁ from t₁ towards t=0. The details options controls the level of details of the informations available in PathResult.\n\nPossible values for the options are\n\n\u001daccuracy::Float64\nmax_corrector_iters::Int\nmax_steps::Int\nstart_parameters::AbstractVector\ntarget_parameters::AbstractVector\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.track!","page":"Path tracker","title":"HomotopyContinuation.track!","text":"track!(tracker::PathTracker, x₁, t₁::Float64=1.0; options...)::PathTrackerStatus.states\n\nTrack the path with start solution x₁ from t₁ towards t=0.\n\nPossible values for the options are\n\n\u001daccuracy::Float64\nmax_corrector_iters::Int\nmax_steps::Int\nstart_parameters::AbstractVector\ntarget_parameters::AbstractVector\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"The return type of track! is","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"PathTrackerStatus.states","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTrackerStatus.states","page":"Path tracker","title":"HomotopyContinuation.PathTrackerStatus.states","text":"PathTrackerStatus.states\n\nThe possible return codes the path tracker can return are\n\nPathTrackerStatus.success\nPathTrackerStatus.at_infinity\nPathTrackerStatus.terminated_maximal_iterations\nPathTrackerStatus.terminated_invalid_startvalue\nPathTrackerStatus.terminated_step_size_too_small\nPathTrackerStatus.terminated_singularity\nPathTrackerStatus.terminated_ill_conditioned\nPathTrackerStatus.terminated\nPathTrackerStatus.post_check_failed\nPathTrackerStatus.excess_solution\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"In the case that you track paths of parameter homotopy you can also change the parameters using","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"set_parameters!(::PathTracker)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.set_parameters!-Tuple{PathTracker}","page":"Path tracker","title":"HomotopyContinuation.set_parameters!","text":"set_parameters!(tracker::PathTracker; start_parameters=nothing, target_parameters=nothing)\n\nSet the parameters of a parameter homotopy.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#PathResult-1","page":"Path tracker","title":"PathResult","text":"","category":"section"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"For each path we return a PathResult containing the detailed information about the single path.","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"PathResult","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathResult","page":"Path tracker","title":"HomotopyContinuation.PathResult","text":"PathResult{V<:AbstractVector}\n\nA PathResult is the result of tracking of a path using PathTracker. Its fields are\n\nreturn_code: One of :success, :at_infinity or any error code in PathTrackerStatus.states converted to a Symbol.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Union{Nothing, Float64}: An approximation of x-x^*₂ where x is the computed solution and x^* is the true solution.\nresidual::Union{Nothing, Float64}: The value of the 2-norm of H(solution, 0).\ncondition_jacobian::Union{Nothing, Float64}: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.\nwinding_number:Union{Nothing, Int}: The estimated winding number. This is a lower bound on the multiplicity of the solution.\nendgame_zone_start::Union{Nothing, Float64}: The value of t at which we entered the endgame zone, i.e., where the path x(t) has an expansion a convergent Puiseux series near t=0.\nstart_solution::Union{Nothing, Int}: The start solution of the path.\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nvaluation::Union{Nothing, Vector{Float64}}: An approximation of the valuation of the Puiseux series expansion of x(t).\nvaluation_accuracy::Union{Nothing, Vector{Float64}}: An estimate of the accuracy of the valuation of the Puiseux series expansion of x(t).\nPathResult(tracker::PathTracker, startsolution=nothing, pathnumber::Union{Nothing,Int}=nothing; details=:default)\n\nPossible details values are :minimal (minimal details), :default (default) and :extensive (all information possible).\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"The following helper functions are provided","category":"page"},{"location":"path_tracker/#","page":"Path tracker","title":"Path tracker","text":"solution\nresidual\nstart_solution\nBase.isreal(::PathResult)\nLinearAlgebra.issuccess(::PathResult)\nisfailed\nisaffine\nisprojective\nisatinfinity\nissingular\nisnonsingular","category":"page"},{"location":"path_tracker/#HomotopyContinuation.solution","page":"Path tracker","title":"HomotopyContinuation.solution","text":"solution(pathresult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.residual","page":"Path tracker","title":"HomotopyContinuation.residual","text":"residual(pathresult)\n\nGet the residual of the solution x of the path, i.e., H(x 0)₂.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.start_solution","page":"Path tracker","title":"HomotopyContinuation.start_solution","text":"start_solution(pathresult)\n\nGet the start solution of the solution x of the path.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#Base.isreal-Tuple{PathResult}","page":"Path tracker","title":"Base.isreal","text":"isreal(pathresult; tol=1e-6)\n\nWe consider a result as real if the 2-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#LinearAlgebra.issuccess-Tuple{PathResult}","page":"Path tracker","title":"LinearAlgebra.issuccess","text":"issuccess(pathresult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.isfailed","page":"Path tracker","title":"HomotopyContinuation.isfailed","text":"isfailed(pathresult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.isaffine","page":"Path tracker","title":"HomotopyContinuation.isaffine","text":"isaffine(pathresult)\n\nReturn`s true if the solution is an affine vector.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.isprojective","page":"Path tracker","title":"HomotopyContinuation.isprojective","text":"isprojective(pathresult)\n\nReturn`s true if the solution is a projective vector.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.isatinfinity","page":"Path tracker","title":"HomotopyContinuation.isatinfinity","text":"isatinfinity(pathresult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.issingular","page":"Path tracker","title":"HomotopyContinuation.issingular","text":"issingular(pathresult; tol=1e10)\n\nChecks whether the path result is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.isnonsingular","page":"Path tracker","title":"HomotopyContinuation.isnonsingular","text":"isnonsingular(pathresult; tol=1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"function"},{"location":"newton/#Newton's-method-1","page":"Newton's method","title":"Newton's method","text":"","category":"section"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"Sometimes it is necessary to refine obtained solutions. For this we provide an interface to Newton's method.","category":"page"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"newton\nNewtonResult\nNewtonReturnCode.codes","category":"page"},{"location":"newton/#HomotopyContinuation.newton","page":"Newton's method","title":"HomotopyContinuation.newton","text":"newton(F::AbstractSystem, x₀, norm=euclidean_norm, cache=NewtonCache(F, x₀); tol=1e-6, miniters=1, maxiters=3, simplified_last_step=true)\n\nAn ordinary Newton's method. If simplified_last_step is true, then for the last iteration the previously Jacobian will be used. This uses an LU-factorization for square systems and a QR-factorization for overdetermined.\n\n\n\n\n\n","category":"function"},{"location":"newton/#HomotopyContinuation.NewtonResult","page":"Newton's method","title":"HomotopyContinuation.NewtonResult","text":"NewtonResult{T}\n\nStructure holding information about the outcome of the newton function. The fields are.\n\nreturn_code::NewtonReturnCode.codes: The return code of computation. NewtonReturnCode.converged means that accuracy ≤ tol.\naccuracy::T: |xᵢ-xᵢ₋₁| for i = iters and x₀,x₁,…,xᵢ₋₁,xᵢ are the Newton iterates.\niters::Int: The number of iterations used.\ndigits_lost::Float64 Estimate of the (relative) lost digits in the linear algebra.\n\n\n\n\n\n","category":"type"},{"location":"newton/#HomotopyContinuation.NewtonReturnCode.codes","page":"Newton's method","title":"HomotopyContinuation.NewtonReturnCode.codes","text":"NewtonReturnCode.codes\n\nThe possible return codes of Newton's method\n\nNewtonReturnCode.converged\nNewtonReturnCode.terminated\nNewtonReturnCode.terminated_no_approximate\nNewtonReturnCode.maximal_iterations\n\n\n\n\n\n","category":"type"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"For high performance applications we also provide an in-place version of Newton's method which avoids any temporary allocations.","category":"page"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"newton!\nNewtonCache","category":"page"},{"location":"newton/#HomotopyContinuation.newton!","page":"Newton's method","title":"HomotopyContinuation.newton!","text":"newton!(out, F::AbstractSystem, x₀, norm, cache::AbstractNewtonCache; tol=1e-6, miniters=1, maxiters=3, simplified_last_step=true)\n\nIn-place version of newton. Needs a NewtonCache and norm as input.\n\n\n\n\n\n","category":"function"},{"location":"newton/#HomotopyContinuation.NewtonCache","page":"Newton's method","title":"HomotopyContinuation.NewtonCache","text":"NewtonCache(F::AbstractSystem, x)\n\nCache for the newton function.\n\n\n\n\n\n","category":"type"},{"location":"sorting/#Sorting-arrays-of-solutions-1","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"We provide functions for sorting analyzing arrays of vectors.","category":"page"},{"location":"sorting/#Computing-unique-points-in-an-array-of-vectors-1","page":"Sorting arrays of solutions","title":"Computing unique points in an array of vectors","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"UniquePoints","category":"page"},{"location":"sorting/#HomotopyContinuation.UniquePoints","page":"Sorting arrays of solutions","title":"HomotopyContinuation.UniquePoints","text":"UniquePoints{V<:AbstractVector, T, F<:Function}\n\nA data structure which holds points of type V where T=real(eltype(V)). This data structure provides an efficient (poly)logarithmic check whether a point already exists where two points u,v are considered equal if F(u,v)<tol, where tol is a tolerance provided through the add! function.\n\nUniquePoints(v::AbstractVector{<:Number}, distance::F)\n\nInitialize the data structure with just one data point v.\n\nUniquePoints(V::Vector{<:AbstractVector{<:Number}}, distance::F; tol=1e-5)\n\nInitialize the data structure with all points in v. These are added in order by add! with the given tolerance tol. In particular, 'UniquePoints' structure will contain only points for which the pairwise distance given by F is less than tol.\n\nUniquePoints(v; kwargs...) = UniquePoints(v, euclidean_distance; kwargs...)\n\nIf F is not specialized, euclidean_distance is used.\n\nOptional keywords:\n\ncheck_real=true adds real from points from group orbits (if they exist). The default is check_real=true.\nThe user can use group_action=foo or, if there is more than one group acting, group_actions=[foo, bar]. Then, points that are in the same group orbit are considered equal. See GroupActions for details regarding the application rules.\n\nExample\n\njulia> UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]])\n[1.0, 0.5]\n[0.5, 1.0]\n\njulia> UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]], group_action = x -> ([x[2];x[1]],))\n[1.0, 0.5]\n\n\n\n\n\n","category":"type"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"We provide several helper functions for UniquePoints.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"points\niscontained\nadd!\nsimple_add!\nempty!","category":"page"},{"location":"sorting/#HomotopyContinuation.points","page":"Sorting arrays of solutions","title":"HomotopyContinuation.points","text":"points(data::UniquePoints)\n\nReturn the points stored in data.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.iscontained","page":"Sorting arrays of solutions","title":"HomotopyContinuation.iscontained","text":"iscontained(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nCheck whether x is contained in the data by using the tolerance tol to decide for duplicates.\n\niscontained(data::UniquePoints{V}, x::V, Val{true}(); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol return the index of the data point which already exists. If the data point is not existing -1 is returned. If data has the option check_real enabled, a -2 will be returned once a real vector was added.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.add!","page":"Sorting arrays of solutions","title":"HomotopyContinuation.add!","text":"add!(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nAdd x to data if it doesn't already exists by using the tolerance tol to decide for duplicates.\n\nadd!(data::UniquePoints{V}, x::V, Val(true); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol to decide for duplicates return the index of the data point which already exists. If the data point is not existing add it to data and return -1. If data has the option check_real enabled, a -2 will be returned once a real vector was added. The element will be the last element of points(data).\n\n\n\n\n\nadd!(node::Node, x; kwargs...)\n\nCalls add! on the points of the Node with option Val(true).\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.simple_add!","page":"Sorting arrays of solutions","title":"HomotopyContinuation.simple_add!","text":"simple_add!(data::UniquePoints{V}, x::V, tol::Real)::Bool\n\nSimilarly to add! but does not apply any group actions. If the data point is not existing add it to data and return -1. Otherwise the index of x in data.points is returned.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#Base.empty!","page":"Sorting arrays of solutions","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(data::UniquePoints)\n\nRemove all points from data.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#Computing-points-in-an-array-of-vectors-which-appear-multiple-times-1","page":"Sorting arrays of solutions","title":"Computing points in an array of vectors which appear multiple times","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"If instead of unique points, the user wants to have the information which points in an array of points appear with multiplicity, they should use the next function.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"multiplicities","category":"page"},{"location":"sorting/#HomotopyContinuation.multiplicities","page":"Sorting arrays of solutions","title":"HomotopyContinuation.multiplicities","text":"multiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"The multiplicities functions may also be applied to Result; see here: multiplicities(::HomotopyContinuation.Results).","category":"page"},{"location":"norms_distances/#Distances-and-norms-1","page":"Norms and Distances","title":"Distances and norms","text":"","category":"section"},{"location":"norms_distances/#","page":"Norms and Distances","title":"Norms and Distances","text":"We provide functions for computing norms and distances.","category":"page"},{"location":"norms_distances/#","page":"Norms and Distances","title":"Norms and Distances","text":"euclidean_distance\neuclidean_norm","category":"page"},{"location":"norms_distances/#HomotopyContinuation.euclidean_distance","page":"Norms and Distances","title":"HomotopyContinuation.euclidean_distance","text":"euclidean_distance(u, v)\n\nCompute ||u-v||₂.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#HomotopyContinuation.euclidean_norm","page":"Norms and Distances","title":"HomotopyContinuation.euclidean_norm","text":"euclidean_norm(u)\n\nCompute ||u||₂.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#","page":"Norms and Distances","title":"Norms and Distances","text":"infinity_distance\ninfinity_norm","category":"page"},{"location":"norms_distances/#HomotopyContinuation.infinity_distance","page":"Norms and Distances","title":"HomotopyContinuation.infinity_distance","text":"infinity_distance(u, v)\n\nCompute the ∞-norm of u-v.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#HomotopyContinuation.infinity_norm","page":"Norms and Distances","title":"HomotopyContinuation.infinity_norm","text":"infinity_norm(z)\n\nCompute the ∞-norm of z. If z is a complex vector this is more efficient than norm(z, Inf).\n\ninfinity_norm(z₁, z₂)\n\nCompute the ∞-norm of z₁-z₂.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#","page":"Norms and Distances","title":"Norms and Distances","text":"fubini_study","category":"page"},{"location":"norms_distances/#HomotopyContinuation.fubini_study","page":"Norms and Distances","title":"HomotopyContinuation.fubini_study","text":"fubini_study(x::PVector, y::PVector)\n\nComputes the Fubini-Study distance between x and y.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Data-structures-for-polynomial-systems-1","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"Polynomial systems can be represented in numerous ways in a computer and each representation has certain tradeoffs. For our purposes the most important thing is that it is fast to evaluate the system. Therefore we automatically convert an input given by DynamicPolynomials to another representation more suitable for numerically evaluations. The default is currently FPSystem.","category":"page"},{"location":"systems/#Default-systems-1","page":"Data structures for polynomial systems","title":"Default systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"We provide the following systems by default.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"FPSystem\nSPSystem\nFixedHomotopy\nFixedParameterSystem\nCompositionSystem","category":"page"},{"location":"systems/#HomotopyContinuation.FPSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FPSystem","text":"FPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a polynomial system using the FixedPolynomials package.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SPSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.SPSystem","text":"SPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a system using the StaticPolynomials package. Note that StaticPolynomials leverages Julias metaprogramming capabilities to automatically generate functions to evaluate the system and its Jacobian. These generated functions are very fast but at the cost of possibly large compile times. The compile time depends on the size of the support of the polynomial system. If you intend to solve a large system or you need to solve a system with the same support but different coefficients even large compile times can be worthwile. As a general rule of thumb this usually is twice as fast as solving the same system using FPSystem.\n\nExample\n\nYou can use SPSystem as follows with solve\n\n@polyvar x y\nF = [x^2+3y^4-2, 2y^2+3x*y+4]\nsolve(F, system=SPSystem)\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedHomotopy","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FixedHomotopy","text":"FixedHomotopy(H, t) <: AbstractSystem\n\nFix a homotopy H(x,t) at t\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedParameterSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FixedParameterSystem","text":"FixedParameterSystem(F, p) <: AbstractSystem\n\nFix a parameterized system F(x; p) at p, i.e., it is treated as a system without parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.CompositionSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.CompositionSystem","text":"CompositionSystem(composition::Composition, systems_constructor) <: AbstractSystem\n\nA system representing the composition of polynomial maps.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Interface-for-custom-systems-1","page":"Data structures for polynomial systems","title":"Interface for custom systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The great thing is that you are not limited to the systems provided by default. Maybe your polynomial system has a particular structure which you want to use to efficiently evaluate it. For this you can define your own homotopy by defining a struct with super type AbstractSystem. For this the following interface has to be defined.","category":"page"},{"location":"systems/#Types-1","page":"Data structures for polynomial systems","title":"Types","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"AbstractSystem\nAbstractSystemCache\nSystemNullCache","category":"page"},{"location":"systems/#HomotopyContinuation.AbstractSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.AbstractSystem","text":"AbstractSystem\n\nRepresenting a system of polynomials.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.AbstractSystemCache","page":"Data structures for polynomial systems","title":"HomotopyContinuation.AbstractSystemCache","text":"AbstractSystemCache\n\nA cache to avoid allocations for the evaluation of an AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SystemNullCache","page":"Data structures for polynomial systems","title":"HomotopyContinuation.SystemNullCache","text":"SystemNullCache\n\nAn empty cache if no cache is necessary.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Mandatory-1","page":"Data structures for polynomial systems","title":"Mandatory","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The following methods are mandatory to implement.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"cache(F::AbstractSystem, args...)\nevaluate!(u, F::AbstractSystem, args...)\nevaluate(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\njacobian!(u, F::AbstractSystem, args...)\njacobian(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\nBase.size(::AbstractSystem)","category":"page"},{"location":"systems/#HomotopyContinuation.cache-Tuple{AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.cache","text":"cache(F::AbstractSystem, x)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x.\n\ncache(F::AbstractSystem, x, p)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x and parameters p.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, F::AbstractSystem, x, cache::AbstractSystemCache)\n\nEvaluate the system F at x and store the result in u.\n\nevaluate!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate","text":"evaluate(F::AbstractSystem, x::AbstractVector, cache=cache(F, x))\n\nEvaluate the system F at x.\n\nevaluate(F::AbstractSystem, x::AbstractVector, p, cache=cache(F, x))\n\nEvaluate the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, F::AbstractSystem, x , cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and store the result in u.\n\njacobian!(u, F::AbstractSystem, x , p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.jacobian","page":"Data structures for polynomial systems","title":"HomotopyContinuation.jacobian","text":"jacobian(F::AbstractSystem, x, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x.\n\njacobian(F::AbstractSystem, x , p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Base.size-Tuple{AbstractSystem}","page":"Data structures for polynomial systems","title":"Base.size","text":"Base.size(F::AbstractSystem)\n\nReturns a tuple (m, n) indicating that F is a system of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"Additionally if the system should support parameter homotopies it needs to support","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"differentiate_parameters!\ndifferentiate_parameters","category":"page"},{"location":"systems/#HomotopyContinuation.differentiate_parameters!","page":"Data structures for polynomial systems","title":"HomotopyContinuation.differentiate_parameters!","text":"differentiate_parameters!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.differentiate_parameters","page":"Data structures for polynomial systems","title":"HomotopyContinuation.differentiate_parameters","text":"differentiate_parameters(F::AbstractSystem, x, p, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters\n\n\n\n\n\n","category":"function"},{"location":"systems/#Optional-1","page":"Data structures for polynomial systems","title":"Optional","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The following methods are mandatory to implement. The following are optional to implement but usually you want to define at least cache.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"evaluate_and_jacobian!(u, U, F::AbstractSystem, x, cache::AbstractSystemCache)\nevaluate_and_jacobian!(u, U, F::AbstractSystem, x, p, cache::AbstractSystemCache)","category":"page"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,AbstractSystemCache}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x , cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,Any,AbstractSystemCache}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and parameters p and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#Homotopies-1","page":"Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"A homotopy is a function","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"H mathbbC^N  mathbbC  mathbbC^n (xt)  H(xt)","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"where H( t) is a polynomial system for all tmathbbC.","category":"page"},{"location":"homotopies/#Default-homotopies-1","page":"Homotopies","title":"Default homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following homotopies are available by default","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"StraightLineHomotopy\nFixedPointHomotopy\nParameterHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.StraightLineHomotopy","page":"Homotopies","title":"HomotopyContinuation.StraightLineHomotopy","text":"StraightLineHomotopy(G, F; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = γtG(x) + (1-t)F(x).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.FixedPointHomotopy","page":"Homotopies","title":"HomotopyContinuation.FixedPointHomotopy","text":"FixedPointHomotopy(F, x₀; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = (1-t)F(x) + γt(x-x₀).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.ParameterHomotopy","page":"Homotopies","title":"HomotopyContinuation.ParameterHomotopy","text":"ParameterHomotopy(F, parameters;\n    variables=setdiff(MP.variables(F), parameters),\n    p₁=randn(ComplexF64, length(parameters)),\n    p₀=randn(ComplexF64, length(parameters)),\n    γ₁=nothing, γ₀=nothing)\n\nConstruct the homotopy\n\nH(x t) = F(x (tγ₁p₁+(1-t)γ₀p₀)  (tγ₁+(1-t)γ₀))\n\nwhere p₁ and p₀ are a vector of parameter values for F and γ₁ and γ₀ are complex numbers. If γ₁ or γ₀ is nothing, it is assumed that γ₁ and γ₀ are 1. The input parameters specifies the parameter variables of F. Neccessarily, length(parameters) == length(p₁) == length(p₀).\n\nNote that p₁ and p₀ are stored as a tuple p of SVectors and γ₁ and γ₀ are stored as a tuple γ or as γ=nothing\n\nParameterHomotopy(F, parameters;\n    variables=setdiff(MP.variables(F), parameters),\n    start_parameters=randn(ComplexF64, length(parameters)),\n    target_parameters=randn(ComplexF64, length(parameters)),\n    start_gamma=nothing, target_gamma=nothing)\n\nThis is a non-unicode variant where γ₁=start_parameters, γ₀=target_parameters, γ₁=start_gamma, γ₀=target_gamma.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"We also provide more specialised homotopies, which are mostly used internally currently but could be useful in conjunction with the CoreTracker primitive.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"PatchedHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.PatchedHomotopy","page":"Homotopies","title":"HomotopyContinuation.PatchedHomotopy","text":"PatchedHomotopy(H::AbstractHomotopy, patch, v::PVector)\n\nAugment the homotopy H with the given patch v. This results in the system [H(x,t); v ⋅ x - 1]\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Interface-for-custom-homotopies-1","page":"Homotopies","title":"Interface for custom homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The great thing is that you are not limited to the homotopies provided by default. You can define your own homotopy by defining a struct with super type AbstractHomotopy. For this the following interface has to be defined.","category":"page"},{"location":"homotopies/#Types-1","page":"Homotopies","title":"Types","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"AbstractHomotopy\nAbstractHomotopyCache\nHomotopyNullCache","category":"page"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopy","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopy","text":"AbstractHomotopy\n\nRepresenting a homotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopyCache","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopyCache","text":"AbstractHomotopyCache\n\nA cache to avoid allocations for the evaluation of an AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.HomotopyNullCache","page":"Homotopies","title":"HomotopyContinuation.HomotopyNullCache","text":"HomotopyNullCache\n\nThe default AbstractHomotopyCache containing nothing.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Mandatory-1","page":"Homotopies","title":"Mandatory","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following methods are mandatory to implement.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"cache(H::AbstractHomotopy, x, t)\nevaluate!(u, F::AbstractHomotopy, args...)\njacobian!(u, H::AbstractHomotopy, args...)\ndt!\nBase.size(::AbstractHomotopy)","category":"page"},{"location":"homotopies/#HomotopyContinuation.cache-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.cache","text":"cache(H::AbstractHomotopy, x, t)::AbstractHomotopyCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x. The default implementation returns HomotopyNullCache.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt!","page":"Homotopies","title":"HomotopyContinuation.dt!","text":"dt!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#Base.size-Tuple{AbstractHomotopy}","page":"Homotopies","title":"Base.size","text":"Base.size(H::AbstractHomotopy)\n\nReturns a tuple (m, n) indicating that H is a homotopy of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#Optional-1","page":"Homotopies","title":"Optional","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"evaluate_and_jacobian!(u, U, H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate_and_jacobian(H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt!(U, u, H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt(H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate(H::AbstractHomotopy, x, t)\njacobian(H::AbstractHomotopy, x, t)\ndt(H::AbstractHomotopy, x, t)\nbasehomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian!","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t) and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian","text":"evaluate_and_jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt!","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt!","text":"jacobian_and_dt!(U, u, H, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t) and store the results in u (evalution) and v (∂t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt","text":"jacobian_and_dt(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.evaluate","text":"evaluate(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.jacobian","text":"jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.dt","text":"dt(H::AbstractHomotopy, x::AbstractVector, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.basehomotopy","page":"Homotopies","title":"HomotopyContinuation.basehomotopy","text":"basehomotopy(H::AbstractHomotopy)\n\nReturns the 'proper' homotopy describing the problem. Any wrapper homotopy recursively calls wrappedhomotopy with the wrapped homotopy as argument.\n\n\n\n\n\n","category":"function"},{"location":"predictors-correctors/#Predictors-and-Correctors-1","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"We use a predictor-corrector scheme to track paths. These are the predictors and correctors currently available.","category":"page"},{"location":"predictors-correctors/#Predictors-1","page":"Predictors and Correctors","title":"Predictors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"The following predictors are currently implemented.","category":"page"},{"location":"predictors-correctors/#","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"Euler\nHeun\nRalston\nRK3\nRK4\nPade21\nNullPredictor","category":"page"},{"location":"predictors-correctors/#HomotopyContinuation.Euler","page":"Predictors and Correctors","title":"HomotopyContinuation.Euler","text":"Euler()\n\nThis uses the explicit Euler method for prediction, also known as the tangent predictor.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Heun","page":"Predictors and Correctors","title":"HomotopyContinuation.Heun","text":"Heun()\n\nThe Heun predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Ralston","page":"Predictors and Correctors","title":"HomotopyContinuation.Ralston","text":"Ralston()\n\nThe Ralston predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.RK3","page":"Predictors and Correctors","title":"HomotopyContinuation.RK3","text":"RK3()\n\nThe classical Runge-Kutta predictor of order 3.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.RK4","page":"Predictors and Correctors","title":"HomotopyContinuation.RK4","text":"RK4()\n\nThe classical Runge-Kutta predictor of order 4.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Pade21","page":"Predictors and Correctors","title":"HomotopyContinuation.Pade21","text":"Pade21()\n\nThis uses a Padé-approximation of type (2,1) for prediction.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.NullPredictor","page":"Predictors and Correctors","title":"HomotopyContinuation.NullPredictor","text":"NullPredictor()\n\nA predictor which does no prediction step, i.e., it just returns the input as its prediction.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#Correctors-1","page":"Predictors and Correctors","title":"Correctors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"The following correctors are currently implemented.","category":"page"},{"location":"predictors-correctors/#","page":"Predictors and Correctors","title":"Predictors and Correctors","text":"NewtonCorrector","category":"page"},{"location":"predictors-correctors/#HomotopyContinuation.NewtonCorrector","page":"Predictors and Correctors","title":"HomotopyContinuation.NewtonCorrector","text":"NewtonCorrector(;simplified_last_step=true)\n\nAn ordinary Newton's method. If simplified_last_step is true, then for the last iteration the previously Jacobian will be used. This uses an LU-factorization for square systems and a QR-factorization for overdetermined.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#Core-Tracker-1","page":"Core tracker","title":"Core Tracker","text":"","category":"section"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"We also export the path tracking primitive to make the core path tracking routine available for other applications. At the heart is a CoreTracker object which holds all the state. The easiest way to construct a CoreTracker is to use the coretracker_startsolutions routine.","category":"page"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"coretracker_startsolutions\ncoretracker","category":"page"},{"location":"core_tracker/#HomotopyContinuation.coretracker_startsolutions","page":"Core tracker","title":"HomotopyContinuation.coretracker_startsolutions","text":"coretracker_startsolutions(args...; kwargs...)\n\nConstruct a CoreTracker and startsolutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.coretracker","page":"Core tracker","title":"HomotopyContinuation.coretracker","text":"coretracker(args...; kwargs...)\n\nConstruct a CoreTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions. This is convenient if you want to investigate single paths.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parameterized system f with parameters p from the parameters a to b.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b)\n\nYou then can obtain a single solution at b by using\n\nx_b = track(tracker, x_a).x\n\nTrace a path\n\nTo trace a path you can use the iterator method.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b, max_step_size =0.01)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\nIf we want to guarantee smooth traces we can limit the maximal step size.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b, max_step_size =0.01)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Types-1","page":"Core tracker","title":"Types","text":"","category":"section"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"CoreTracker\nCoreTrackerResult\nCoreTrackerStatus.states","category":"page"},{"location":"core_tracker/#HomotopyContinuation.CoreTracker","page":"Core tracker","title":"HomotopyContinuation.CoreTracker","text":" CoreTracker(H::AbstractHomotopy, x₁, t₁, t₀; options...)::CoreTracker\n\nCreate a CoreTracker to track x₁ from t₁ to t₀. The homotopy H needs to be homogeneous. Note that a CoreTracker is also a (mutable) iterator.\n\nCoreTrackerOptions\n\ncorrector::AbstractCorrector: The corrector used during in the predictor-corrector scheme. The default is NewtonCorrector.\nmax_corrector_iters=3: The maximal number of correction steps in a single step.\ninitial_step_size=0.1: The step size of the first step.\nmax_steps=1_000: The maximal number of iterations the path tracker has available.\nmin_step_size=1e-14: The minimal step size.\nmax_step_size=Inf: The maximal step size.\nmaximal_lost_digits::Real=-(log₁₀(eps) + 3): The tracking is terminated if we estimate that we loose more than maximal_lost_digits in the linear algebra steps.\npredictor::AbstractPredictor: The predictor used during in the predictor-corrector scheme. The default is Heun()`.\nmax_refinement_iters=10: The maximal number of correction steps used to refine the final value.\nrefinement_accuracy=1e-8: The precision used to refine the final value.\naccuracy=1e-7: The precision used to track a value.\nauto_scaling=true: This only applies if we track in affine space. Automatically regauges the variables to effectively compute with a relative accuracy instead of an absolute one.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerResult","page":"Core tracker","title":"HomotopyContinuation.CoreTrackerResult","text":" CoreTrackerResult{V<:AbstractVector}\n\nContaining the result of a tracked path. The fields are\n\nreturncode::CoreTrackerStatus.states If the tracking was successfull then it is CoreTrackerStatus.success.\nx::V The result.\nt::ComplexF64 The t when the path tracker stopped.\naccuracy::Float64: The estimated accuracy of x.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerStatus.states","page":"Core tracker","title":"HomotopyContinuation.CoreTrackerStatus.states","text":"CoreTrackerStatus.states\n\nThe possible states the coretracker can achieve are\n\nCoreTrackerStatus.success\nCoreTrackerStatus.tracking\nCoreTrackerStatus.terminated_maximal_iterations\nCoreTrackerStatus.terminated_invalid_startvalue\nCoreTrackerStatus.terminated_step_size_too_small\nCoreTrackerStatus.terminated_singularity\nCoreTrackerStatus.terminated_ill_conditioned\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#Methods-1","page":"Core tracker","title":"Methods","text":"","category":"section"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"To track from a start to an endpoint with the CoreTracker we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"track(tracker::CoreTracker, x₁::AbstractVector, t₁=1.0, t₀=0.0; kwargs...)\ntrack!(x₀, tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0; setup_patch=tracker.options.update_patch, checkstartvalue=true, compute_ẋ=true)\nsetup!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.track","page":"Core tracker","title":"HomotopyContinuation.track","text":"track(tracker, x₁, t₁=1.0, t₀=0.0; options...)::CoreTrackerResult\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. This returns a CoreTrackerResult. This modifies tracker. See track! for the possible options.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.track!","page":"Core tracker","title":"HomotopyContinuation.track!","text":" track!(tracker, x₁, t₁=1.0, t₀=0.0; setup_patch=true, checkstartvalue=true, compute_ẋ=true)\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. Returns one of the enum values of CoreTrackerStatus.states indicating the status. If the tracking was successfull it is CoreTrackerStatus.success. If setup_patch is true then setup! is called at the beginning of the tracking.\n\ntrack!(x₀, tracker, x₁, t₁=1.0, t₀=0.0; options...)\n\nAdditionally also stores the result in x₀ if the tracking was successfull.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.setup!","page":"Core tracker","title":"HomotopyContinuation.setup!","text":"setup!(::AbstractAffinePatchState, x::AbstractVector)\n\nSetup the affine patch depending on x and modify x if necessary. This is only called once at the beginning of a tracked path.\n\n\n\n\n\nsetup!(cache::AbstractStatefulPredictorCache, H, x, ẋ, t, Jac)\n\nSetup the cache. x is the new path value at t and ẋ is the derivative at t. fac is a factorization of the Jacobian at (x,t). This falls back to calling update.\n\n\n\n\n\nsetup!(coretracker, x₁, t₁=1.0, t₀=0.0, setup_patch=coretracker.options.update_patch, checkstartvalue=true, compute_ẋ=true)\n\nSetup coretracker to track x₁ from t₁ to t₀. Use this if you want to use the coretracker as an iterator.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"It is also possible to use a CoreTracker as an iterator. This can either be done by the high level iterator method or by directly using a CoreTracker as an iterator. The recommend approach is simply using iterator.","category":"page"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"iterator","category":"page"},{"location":"core_tracker/#HomotopyContinuation.iterator","page":"Core tracker","title":"HomotopyContinuation.iterator","text":"iterator(tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0; affine=true)\n\nPrepare a tracker to make it usable as a (stateful) iterator. Use this if you want to inspect a specific path. In each iteration the tuple (x,t) is returned. If affine == true then x is the affine solution (internally we compute in projective space).\n\nExample\n\nAssume you have CoreTracker tracker and you wan to track x₁ from 1.0 to 0.25:\n\nfor (x,t) in iterator(tracker, x₁, 1.0, 0.25)\n    println(\"x at t=$t:\")\n    println(x)\nend\n\nNote that this is a stateful iterator. You can still introspect the state of the tracker. For example to check whether the tracker was successfull (and did not terminate early due to some problem) you can do\n\nprintln(\"Success: \", currstatus(tracker) == CoreTrackerStatus.success)\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Introspecting-the-current-state-1","page":"Core tracker","title":"Introspecting the current state","text":"","category":"section"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"To introspect the current state we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"currx\ncurrt\ncurrΔt\ncurriters\ncurrstatus","category":"page"},{"location":"core_tracker/#HomotopyContinuation.currx","page":"Core tracker","title":"HomotopyContinuation.currx","text":"currx(tracker::CoreTracker)\n\nReturn the current value of x.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.currt","page":"Core tracker","title":"HomotopyContinuation.currt","text":" currt(tracker::CoreTracker)\n\nCurrent t.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.currΔt","page":"Core tracker","title":"HomotopyContinuation.currΔt","text":" currΔt(tracker::CoreTracker)\n\nCurrent step_size Δt.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.curriters","page":"Core tracker","title":"HomotopyContinuation.curriters","text":" curriters(tracker::CoreTracker)\n\nCurrent number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.currstatus","page":"Core tracker","title":"HomotopyContinuation.currstatus","text":" currstatus(tracker::CoreTracker)\n\nCurrent status.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Changing-options-1","page":"Core tracker","title":"Changing options","text":"","category":"section"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"To change settings","category":"page"},{"location":"core_tracker/#","page":"Core tracker","title":"Core tracker","text":"accuracy\nset_accuracy!\nmax_corrector_iters\nset_max_corrector_iters!\nmax_step_size\nset_max_step_size!\nmax_refinement_iters\nset_max_refinement_iters!\nrefinement_accuracy\nset_refinement_accuracy!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.accuracy","page":"Core tracker","title":"HomotopyContinuation.accuracy","text":" accuracy(tracker::CoreTracker)\n\nCurrent accuracy.\n\n\n\n\n\naccuracy(pathresult)\n\nGet the accuracy of the solution x of the path, i.e., H(x 0)₂.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_accuracy!","page":"Core tracker","title":"HomotopyContinuation.set_accuracy!","text":" set_accuracy!(tracker::CoreTracker, accuracy)\n\nSet the current accuracy to accuracy.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_corrector_iters","page":"Core tracker","title":"HomotopyContinuation.max_corrector_iters","text":" max_corrector_iters(tracker::CoreTracker)\n\nCurrent correction max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_corrector_iters!","page":"Core tracker","title":"HomotopyContinuation.set_max_corrector_iters!","text":" set_max_corrector_iters!(tracker::CoreTracker, n)\n\nSet the correction max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_step_size","page":"Core tracker","title":"HomotopyContinuation.max_step_size","text":" max_step_size (tracker::CoreTracker)\n\nCurrent maximal step size.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_step_size!","page":"Core tracker","title":"HomotopyContinuation.set_max_step_size!","text":" set_max_corrector_iters!(tracker::CoreTracker, Δs)\n\nSet the maximal step size to Δs.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_refinement_iters","page":"Core tracker","title":"HomotopyContinuation.max_refinement_iters","text":" max_refinement_iters(tracker::CoreTracker)\n\nCurrent refinement max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_refinement_iters!","page":"Core tracker","title":"HomotopyContinuation.set_max_refinement_iters!","text":" set_max_refinement_iters!(tracker::CoreTracker, n)\n\nSet the current refinement max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.refinement_accuracy","page":"Core tracker","title":"HomotopyContinuation.refinement_accuracy","text":" refinement_accuracy(tracker::CoreTracker)\n\nCurrent refinement accuracy.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_refinement_accuracy!","page":"Core tracker","title":"HomotopyContinuation.set_refinement_accuracy!","text":" set_max_refinement_iters!(tracker::CoreTracker, accuracy)\n\nSet the current refinement accuracy to accuracy.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Input-1","page":"Reference","title":"Input","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We support any polynomials which follow the MultivariatePolynomials interface. By default we export the routines @polyvar, PolyVar, differentiate and variables from the DynamicPolynomials implementation. With these you can simply create variables","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"# Create variables x, y, z\n@polyvar x y z\nf = x^2+y^2+z^2\n\n# You can also create an array of variables\n@polyvar x[1:3] # This creates x1, x2, x3 accessed by x[1], x[2], x[3]\nf = dot(x, x) # = x[1]^2+x[2]^2+x[3]^2\n\n# Also you can create matrices of variables\n# This creates x1_1, x1_2, x2_1, x2_2 accessed by\n# x[1,1], x[1,2], x[2,1], x[2,2]\n@polyvar x[1:2, 1:2]","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We also provide methods construct compositions of polynomial systems:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"compose","category":"page"},{"location":"reference/#HomotopyContinuation.compose","page":"Reference","title":"HomotopyContinuation.compose","text":"compose(g, f)::Composition\n\nCompose the polynomial systems g and f. You can also use the infix operator ∘ (written by \\circ).\n\njulia> @polyvar a b c x y z;\njulia> g = [a * b * c];\njulia> f = [x+y, y + z, x + z];\njulia> expand(compose(g, f))\n1-element Array{DynamicPolynomials.Polynomial{true,Int64},1}:\n x²y + x²z + xy² + 2xyz + xz² + y²z + yz²\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities-1","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"bezout_number\nishomogeneous\nuniquevar\nhomogenize","category":"page"},{"location":"reference/#HomotopyContinuation.bezout_number","page":"Reference","title":"HomotopyContinuation.bezout_number","text":"bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)\nbezout_number(multidegrees, groups::VariableGroups)\n\nCompute the multi-homogeneous bezout number associated to the given system and variable groups.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.ishomogeneous","page":"Reference","title":"HomotopyContinuation.ishomogeneous","text":"ishomogeneous(f::MP.AbstractPolynomialLike)\n\nChecks whether f is homogeneous.\n\nishomogeneous(f::MP.AbstractPolynomialLike, vars)\n\nChecks whether f is homogeneous in the variables vars with possible weights.\n\n\n\n\n\nishomogeneous(F::Vector{MP.AbstractPolynomialLike}, variables)\n\nChecks whether each polynomial in F is homogeneous in the variables variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.uniquevar","page":"Reference","title":"HomotopyContinuation.uniquevar","text":"uniquevar(f::MP.AbstractPolynomialLike, tag=:x0)\nuniquevar(F::MPPolys, tag=:x0)\n\nCreates a unique variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.homogenize","page":"Reference","title":"HomotopyContinuation.homogenize","text":"homogenize(f::MP.AbstractPolynomial, variable=uniquevar(f))\n\nHomogenize the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, variable=uniquevar(F))\n\nHomogenize each polynomial in F by using the given variable variable.\n\nhomogenize(f::MP.AbstractPolynomial, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(f))\n\nHomogenize the variables v in the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(F))\n\nHomogenize the variables v in each polynomial in F by using the given variable variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AffinePatches-1","page":"Reference","title":"AffinePatches","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Affine patches are there to augment projective system such that they can be considered as (locally) affine system. By default the following patches are defined","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"OrthogonalPatch\nEmbeddingPatch\nRandomPatch\nFixedPatch","category":"page"},{"location":"reference/#HomotopyContinuation.OrthogonalPatch","page":"Reference","title":"HomotopyContinuation.OrthogonalPatch","text":"OrthogonalPatch()\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.EmbeddingPatch","page":"Reference","title":"HomotopyContinuation.EmbeddingPatch","text":"EmbeddingPatch()\n\nHolds an PVector onto its affine patch. With this the effect is basically the same as tracking in affine space.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.RandomPatch","page":"Reference","title":"HomotopyContinuation.RandomPatch","text":"RandomPatch()\n\nA random patch. The vector has norm 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.FixedPatch","page":"Reference","title":"HomotopyContinuation.FixedPatch","text":"FixedPatch()\n\n\n\n\n\n","category":"type"}]
}
