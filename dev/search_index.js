var documenterSearchIndex = {"docs":
[{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for solving systems of polynomials equations with only finitely many solutions using numerical homotopy continuation. If this is your first time reading this documentation, we recommend you start with the getting started guide.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n  \"solving.md\",\n  \"monodromy.md\",\n  \"path_tracker.md\",\n  \"newton.md\",\n  \"sorting.md\",\n  \"norms_distances.md\",\n  \"systems.md\",\n  \"homotopies.md\",\n  \"predictors-correctors.md\",\n  \"core_tracker.md\",\n  \"reference.md\"]","category":"page"},{"location":"solving/#Solving-general-polynomial-systems-1","page":"Solving general systems","title":"Solving general polynomial systems","text":"","category":"section"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"The solve function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our How does it work? guide.","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"solve","category":"page"},{"location":"solving/#HomotopyContinuation.solve","page":"Solving general systems","title":"HomotopyContinuation.solve","text":"solve(args...; options...)::Result\n\nThe solve function takes many different arguments and options depending on your specific situation, but in the it always returns a Result containing the result of the computations. In the following we show the different inputs solve takes and at the end we list all possible options.\n\nTotal Degree Homotopy\n\nsolve(F; options...)\n\nSolve the system F using a start system computed from the degrees of the entries of F. The number of paths to track is equal to the total degree d1⋯dn, where di is the degree of the ith entry of F. F can be\n\nVector{<:MultivariatePolynomials.AbstractPolynomial} (e.g. constructed by @polyvar)\nA composition of polynomial systems constructed by compose.\nAbstractSystem (the system has to represent a homogeneous polynomial system.)\n\nExample\n\nWe can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way:\n\njulia> @polyvar x y;\njulia> solve([x^2+y^2+1, 2x+3y-1])\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 661766\n\nPolyhedral Homotopy\n\nsolve(F; start_system = :polyhedral, only_torus=false, options...)\n\nSolve the system F using a start system computed from the Newton Polytopes of the entries F. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of F. The mixed volume is at most the total degree of F. F can be\n\nVector{<:MultivariatePolynomials.AbstractPolynomial} (e.g. constructed by @polyvar)\nA composition of polynomial systems constructed by compose.\nAbstractSystem (the system has to represent a homogeneous polynomial system.)\n\nIf only_torus == true then only solutions in the algebraic torus (ℂsetminus 0)^n will be computed.\n\nExample\n\nWe can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way:\n\njulia> @polyvar x y;\njulia> solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral)\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 222880\n\n# Homogeneous Systems\n\nIf `F` has is homogeneous, we return results in projective space\n\n### Examples\n\njulia julia> @polyvar x y z; julia> solve([x^2+y^2+z^2, 2x+3y-z]) Result with 2 solutions ================================== • 2 non-singular solutions (0 real) • 0 singular solutions (0 real) • 2 paths tracked • random seed: 291729\n\n\nIf your polynomial system is already homogeneous, but you would like to consider it as an affine system\nyou can do\n\njulia @polyvar x y z solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)\n\nThis yields the same result as `solve([x^2+y^2+1, 2x+3y-1])`.\n\n# Multihomogeneous Systems\n\nBy exploiting the multi-homogenous structure of a polynomial system it is possible\nto decrease the number of paths necessary to track.\n\njulia @polyvar x y\n\nUse variable groups to only track 2 paths instead of 4\n\nsolve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])\n\nTo check whether a certain variable grouping is beneficial you can use the [`bezout_number`](@ref)\nfunction.\n\n\n# Start Target Homotopy\n\n    solve(G, F, start_solutions; options...)\n\nThis constructs the homotopy ``H(x,t) = tG(x)+(1-t)F(x)`` to compute solutions of the\nsystem `F`. `start_solutions` is a list of solutions of `G` which are tracked to solutions\nof `F`.\n\n### Example\n\njulia @polyvar x y G = [x^2-1,y-1] F = [x^2+y^2+z^2, 2x+3y-z] solve(G, F, [[1, 1], [-1, 1]])\n\n\n# Parameter Homotopy\n\n    solve(F, startsolutions; parameters, start_parameters, target_parameters, start_gamma=nothing, target_gamma=nothing)\n\nSolve the parameter homotopy\n\nmath H(x, t) = F(x, (tγ₁p₁+(1-t)γ₀p₀) / (tγ₁+(1-t)γ₀)),\n\nwhere ``p₁`` (=`start_parameters`) and ``p₀`` (=`target_parameters`) are vectors of parameter values for ``F`` and\n``γ₁`` (=`start_gamma`) and ``γ₀`` (=`target_gamma`) are complex numbers.\nIf `start_parameters` or `target_parameters` is `nothing`, it is assumed that `γ₁` and `γ₀` are ``1``.\nThe input `parameters` specifies the variables of `F` which should be considered as parameters.\nNecessarily we have `length(parameters) == length(p₁) == length(p₀)`.\n\n    solve(F, startsolutions; parameters, p₁, p₀, γ₁=nothing, γ₀=nothing)\n\nThis is a unicode variant where `γ₁=start_parameters`, `γ₀=target_parameters`,\n    `γ₁=start_gamma`, γ₀=`target_gamma`.\n\n### Example\nWe want to solve a parameter homotopy ``H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])`` where\n\nmath F(x; a) := (x₁^2-a₁, x₁x₂-a₁+a₂)\n\nand let's say we are only intersted in tracking of ``[1,1]``.\nThis can be accomplished as follows\n\njulia @polyvar x[1:2] a[1:2] F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]] startsolutions = [[1, 1]] p₁ = [1, 0] p₀ = [3im, 0.5+2im] solve(F, startsolutions; parameters=a, startparameters=p₁, targetparameters=p₀)\n\nIf you like unicode this is also possible\n\nsolve(F, startsolutions; parameters=a, p₁=p₁, p₀=p₀) ```\n\nAbstract Homotopy\n\nsolve(H::AbstractHomotopy, start_solutions; options...)\n\nSolve the homotopy H by tracking the each solution of H( t) (as provided by start_solutions) from t=1 to t=0. Note that H has to be a homotopy between homogeneous polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. solve(H, startsolutions, homvar=3) if the third variable is the homogenization variable.\n\nOptions\n\nGeneral options:\n\nseed::Int: The random seed used during the computations.\nshow_progress=true: Whether a progress bar should be printed to standard out.\nthreading=true: Enable or disable multi-threading.\npath_result_details=:default: The amount of information computed in each path result. Possible values are :minimal (minimal details), :default (default) and :extensive (all information possible).\nhomvar::Union{Int,MultivariatePolynomials.AbstractVariable}: This considers the homogeneous system F as an affine system which was homogenized by homvar. If F is an AbstractSystem homvar is the index (i.e. Int) of the homogenization variable. If F is an AbstractVariables (e.g. created by @polyvar x) homvar is the actual variable used in the system F.\nsystem::AbstractSystem: A constructor to assemble a AbstractSystem. The default is SPSystem. This constructor is only applied to the input of solve. The constructor is called with system(polynomials, variables) where polynomials is a vector of MultivariatePolynomials.AbstractPolynomials and variables determines the variable ordering. If you experience significant compilation times, consider to change system to FPSystem.\nhomotopy::AbstractHomotopy: A constructor to construct a AbstractHomotopy for the totaldegree and start target homotopy. The default is StraightLineHomotopy. The constructor is called with homotopy(start, target) where start and target are homogeneous AbstractSystems.\naffine_tracking::Bool=true: Indicate whether path tracking should happen in affine space.\nprojective_tracking::Bool=false: Indicate whether path tracking should happen in projective space. The flag affine_tracking is dominant.\npath_jumping_check::Bool=true: Enable a check whether one of the paths jumped to another one.\n\nPath tracking specific options:\n\naccuracy=1e-7: The accuracy required during the path tracking.\ncorrector::AbstractCorrector: The corrector used during in the predictor-corrector scheme. The default is NewtonCorrector.\ninitial_step_size=0.1: The size of the first step.\nmax_corrector_iters=2: The maximal number of correction steps in a single step.\nmax_lost_digits::Real: The tracking is terminated if we estimate that we loose more than max_lost_digits in the linear algebra steps. This threshold depends on the precision argument.\nmax_refinement_iters=5: The maximal number of correction steps used to refine the final value.\nmax_steps=1_000: The maximal number of iterations the path tracker has available. Note that this changes to 10_000 for parameter homotopies.\nmax_step_size=Inf: The maximal step size.\nmin_step_size=1e-14: The minimal step size.\nprecision::PrecisionOption=PRECISION_FIXED_64: The precision used for evaluating the residual in Newton's method.\npredictor::AbstractPredictor: The predictor used during in the predictor-corrector scheme. The default is Heun()`.\nrefinement_accuracy=1e-8: The precision required for the final value.\nsimple_step_size_alg=false: Use a more simple step size algorithm.\nsteps_jacobian_info_update::Int=1: Every n-th step a linear system will be solved using a QR factorization to obtain an estimate for the condition number of the Jacobian.\nterminate_ill_conditioned::Bool=true: Indicates whether the path tracking should be terminated for ill-conditioned paths. A path is considerd ill-conditioned if the condition number of the Jacobian is larger than ≈1e14 or if it is larger than 1emax_lost_digits.\n\nEndgame specific options:\n\naccuracy_eg::Float64=min(accuracy, 1e-5)): It is possible to change the accuracy during the path tracking. Usually you want lower the accuracy.\ncond_eg_start::Float64=1e4: The endgame is only started if the condition of the Jacobian is larger than this threshold.\nmax_winding_number::Int=12: This limits the maximal number of loops taken in applying Cauchy's formula.\nmin_cond_at_infinity::Float64=1e7: A path is declared as going to infinity only if it's Jacobian is also larger than this threshold.\nsamples_per_loop::Int=12: To compute singular solutions Cauchy's integral formula is used. The accuracy of the solutions increases with the number of samples per loop.\nt_eg_start::Float64=0.1: The endgame starts only if t is smaller than this threshold.\ntol_val_inf_accurate::Float64=1e-4: A valuation which would result in a path declared as going to infinity is only accepted if the estimated accuracy of the valuation is less than this threshold.\ntol_val_finite_accurate::Float64=1e-3: A valuation which would result in a proper solution is only accepted if the estimated accuracy of the valuation is less than this threshold. This is only affects solutions where the path has at some point near 0 a condition number larger than cond_eg_start.\n\nIt is recommended to also take a look at the PathTracker documentation for some context.\n\nOverdetermined system specific options:\n\noverdetermined_min_accuracy=1e-5: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.\noverdetermined_min_residual=1e-3: The minimal residual a singular solution needs to have to be considered a solution of the original system.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Result-1","page":"Solving general systems","title":"Result","text":"","category":"section"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"A call to solve returns a Result:","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"Result\nseed","category":"page"},{"location":"solving/#HomotopyContinuation.Result","page":"Solving general systems","title":"HomotopyContinuation.Result","text":"Result{V<:AbstractVector}\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional informations like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"solving/#HomotopyContinuation.seed","page":"Solving general systems","title":"HomotopyContinuation.seed","text":"seed(result)\n\nThe random seed used in the computation.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"The nonsingular solutions are obtained as follows.","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"nonsingular","category":"page"},{"location":"solving/#HomotopyContinuation.nonsingular","page":"Solving general systems","title":"HomotopyContinuation.nonsingular","text":"nonsingular(result::Results; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; only_nonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"The singular solutions are returned by using the following.","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"singular","category":"page"},{"location":"solving/#HomotopyContinuation.singular","page":"Solving general systems","title":"HomotopyContinuation.singular","text":"singular(R::Results; tol=1e10, multiple_results=false, kwargs...)\n\nReturn all PathResults for which the solution is singular. A solution is labeled singular if the condition number is greater than singular_tol, or if the winding number is > 1. If multiple_results=false only one point from each cluster of multiple solutions is returned. If If multiple_results=true all singular solutions in R are returned. For the possible kwargs see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"In order to analyse a Result we provide the following additional helper functions","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"results\nmapresults\nsolutions\nreal_solutions\nfinite\nBase.real(::HomotopyContinuation.Results)\nat_infinity\nfailed\nmultiplicities!(::HomotopyContinuation.Result)\nmultiplicities(::HomotopyContinuation.Results)","category":"page"},{"location":"solving/#HomotopyContinuation.results","page":"Solving general systems","title":"HomotopyContinuation.results","text":"results(result; only_real=false, real_tol=1e-6, only_nonsingular=false,\n            onlysigular=false, singular_tol=1e10, onlyfinite=true, multiple_results=false)\n\nReturn all PathResults for which the given conditions apply.\n\nExample\n\nR = solve(F)\n\n# This gives us all PathResults considered non-singular and real (but still as a complex vector).\nreal_solutions = results(R, only_real=true, only_nonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.mapresults","page":"Solving general systems","title":"HomotopyContinuation.mapresults","text":"mapresults(f::Function, result; conditions...)\n\nApply the function f to all PathResults for which the given conditions apply. For the possible conditions see results.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nreal_solutions = mapresults(solution, R, only_real=true)\n\n\n\n\n\nmapresults(f, result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nApply the function f to all entries of MonodromyResult for which the given conditions apply.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nreal_solutions = mapresults(solution, R, only_real=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.solutions","page":"Solving general systems","title":"HomotopyContinuation.solutions","text":"solutions(result; conditions...)\n\nReturn all solution (as Vectors) for which the given conditions apply. For the possible conditions see results.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> solutions(result)\n[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]\n\n\n\n\n\nsolutions(loop::Loop)\n\nGet the solutions of the loop.\n\n\n\n\n\nsolutions(result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nReturn all solutions (as SVectors) for which the given conditions apply.\n\nExample\n\nreal_solutions = solutions(R, only_real=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.real_solutions","page":"Solving general systems","title":"HomotopyContinuation.real_solutions","text":"real_solutions(result; tol=1e-6, conditions...)\n\nReturn all real solution (as Vectors of reals) for which the given conditions apply. For the possible conditions see results. Note that only_real is always true and real_tol is now tol.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> real_solutions(result)\n[[2.0, -5.0], [-3.0, 0.0]]\n\n\n\n\n\nreal_solutions(res::MonodromyResult; tol=1e-6)\n\nReturns the solutions of res whose imaginary part has norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.finite","page":"Solving general systems","title":"HomotopyContinuation.finite","text":"finite(result::AffineResults; conditions...)\n\nReturn all PathResults for which the solution is finite. This is just a shorthand for results(R; onlyfinite=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Base.real-Tuple{Union{Array{#s507,1} where #s507<:PathResult, Result}}","page":"Solving general systems","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See is_real for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#HomotopyContinuation.at_infinity","page":"Solving general systems","title":"HomotopyContinuation.at_infinity","text":"at_infinity(result::AffineResult)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.failed","page":"Solving general systems","title":"HomotopyContinuation.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.multiplicities!-Tuple{Result}","page":"Solving general systems","title":"HomotopyContinuation.multiplicities!","text":"multiplicities!(result::Result; tol=1e-6)\n\nCompute the multiplicities of the solutions in result with respect to the given tolerance.\n\n\n\n\n\n","category":"method"},{"location":"solving/#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s507,1} where #s507<:PathResult, Result}}","page":"Solving general systems","title":"HomotopyContinuation.multiplicities","text":"multiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"If you are interested in the number of solutions of a certain kind we also provide the following helper functions.","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"nresults\nnfinite\nnreal\nnsingular\nnnonsingular\nnat_infinity\nnfailed","category":"page"},{"location":"solving/#HomotopyContinuation.nresults","page":"Solving general systems","title":"HomotopyContinuation.nresults","text":"nresults(result; only_real=false, real_tol=1e-6, only_nonsingular=false, singular_tol=1e10, onlyfinite=true)\n\nThe number of solutions which satisfy the corresponding predicates.\n\nExample\n\nresult = solve(F)\n# Get all non-singular results where all imaginary parts are smaller than 1e-8\nnresults(result, only_real=true, real_tol=1e-8, only_nonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfinite","page":"Solving general systems","title":"HomotopyContinuation.nfinite","text":"nfinite(result)\n\nThe number of finite solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nreal","page":"Solving general systems","title":"HomotopyContinuation.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions where all imaginary parts of each solution are smaller than tol.\n\n\n\n\n\nnreal(res::MonodromyResult; tol=1e-6)\n\nCounts how many solutions of res have imaginary part norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nsingular","page":"Solving general systems","title":"HomotopyContinuation.nsingular","text":"nsingular(result; singular_tol=1e10, multiplicitytol=1e-5, counting_multiplicities=false, kwargs...)\n\nThe number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than tol. If counting_multiplicities=true the number of singular solutions times their multiplicities is returned.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nnonsingular","page":"Solving general systems","title":"HomotopyContinuation.nnonsingular","text":"nnonsingular(result; tol=1e-10)\n\nThe number of non-singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nat_infinity","page":"Solving general systems","title":"HomotopyContinuation.nat_infinity","text":"nat_infinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfailed","page":"Solving general systems","title":"HomotopyContinuation.nfailed","text":"nafailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"Also make sure to check the documentation for PathResult.","category":"page"},{"location":"solving/#Estimate-the-complexity-1","page":"Solving general systems","title":"Estimate the complexity","text":"","category":"section"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"We provide methods to compute the maximal number of solutions of polynomial systems.","category":"page"},{"location":"solving/#","page":"Solving general systems","title":"Solving general systems","text":"bezout_number\nmixed_volume","category":"page"},{"location":"solving/#HomotopyContinuation.bezout_number","page":"Solving general systems","title":"HomotopyContinuation.bezout_number","text":"bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)\nbezout_number(multidegrees, groups::VariableGroups)\n\nCompute the multi-homogeneous bezout number associated to the given system and variable groups.\n\n\n\n\n\n","category":"function"},{"location":"solving/#MixedSubdivisions.mixed_volume","page":"Solving general systems","title":"MixedSubdivisions.mixed_volume","text":"mixed_volume(F::Vector{<:MP.AbstractPolynomialLike}; show_progress=true, algorithm=:regeneration)\nmixed_volume(𝑨::Vector{<:Matrix}; show_progress=true, algorithm=:regeneration)\n\nCompute the mixed volume of the given polynomial system F resp. represented by the support 𝑨. There are two possible values for algorithm:\n\n:total_degree: Use the total degree homotopy algorithm described in Section 7.1\n:regeneration: Use the tropical regeneration algorithm described in Section 7.2\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Monodromy-Solve-1","page":"Solving paremeterized systems with monodromy","title":"Monodromy Solve","text":"","category":"section"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"Next to solve, HomotopyContinuation.jl provides the function monodromy_solve. Instead of taking two systems f and g and tracking an array of start solutions from f to g, monodromy_solve takes as input a single system with parameters p and together with a start solution s. Then by tracking s around loops in the parameters p, monodromy_solve tries to find new solutions until a stopping criterion is reached. Make sure to check out our monodromy guide for a more in depth introduction into this method.","category":"page"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"monodromy_solve\nMonodromyResult\nsolutions(::MonodromyResult)\nparameters(::MonodromyResult)","category":"page"},{"location":"monodromy/#HomotopyContinuation.monodromy_solve","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.monodromy_solve","text":"monodromy_solve(F, sols, p; parameters=..., options..., pathtrackerkwargs...)\n\nSolve a polynomial system F(x;p) with specified parameters and initial solutions sols by monodromy techniques. This makes loops in the parameter space of F to find new solutions.\n\nOptions\n\ntarget_solutions_count=nothing: The computations are stopped if this number of solutions is reached.\ndone_callback=always_false: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution x and the second one are all current solutions (including x). Return true if the compuation is done.\nmax_loops_no_progress::Int=10: The maximal number of iterations (i.e. loops generated) without any progress.\ngroup_action=nothing: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.\nstrategy: The strategy used to create loops. If F only depends linearly on p this will be Petal. Otherwise this will be Triangle with weights if F is a real system.\nshow_progress=true: Enable a progress meter.\ndistance_function=euclidean_distance: The distance function used for UniquePoints.\nidentical_tol::Float64=1e-6: The tolerance with which it is decided whether two solutions are identical.\ngroup_actions=nothing: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions foo and bar you can set group_actions=[foo, bar]. See GroupActions for details regarding the application rules.\ngroup_action_on_all_nodes=false: By default the group_action(s) are only applied on the solutions with the main parameter p. If this is enabled then it is applied for every parameter q.\nparameter_sampler=independent_normal: A function taking the parameter p and returning a new random parameter q. By default each entry of the parameter vector is drawn independently from the univariate normal distribution.\nequivalence_classes=true: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.\ncheck_startsolutions=true: If true, we do a Newton step for each entry of solsfor checking if it is a valid startsolutions. Solutions which are not valid are sorted out.\ntimeout=float(typemax(Int)): The maximal number of seconds the computation is allowed to run.\nmin_solutions: The minimal number of solutions before a stopping heuristic is applied. By default this is half of target_solutions_count if applicable otherwise 2.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#HomotopyContinuation.MonodromyResult","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.MonodromyResult","text":"MonodromyResult\n\nThe monodromy result contains the result of the monodromy_solve computation.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.solutions-Tuple{MonodromyResult}","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.solutions","text":"solutions(result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nReturn all solutions (as SVectors) for which the given conditions apply.\n\nExample\n\nreal_solutions = solutions(R, only_real=true)\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.parameters-Tuple{MonodromyResult}","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.parameters","text":"parameters(r::MonodromyResult)\n\nReturn the parameters corresponding to the given result r.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#GroupActions-1","page":"Solving paremeterized systems with monodromy","title":"GroupActions","text":"","category":"section"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"If there is a group acting on the solution set of the polynomial system this can provided with the group_action keyword for single group actions or with the group_actions keyword for compositions of group actions. These will be internally transformed into GroupActions.","category":"page"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"GroupActions","category":"page"},{"location":"monodromy/#HomotopyContinuation.GroupActions","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.GroupActions","text":"GroupActions(actions::Function...)\n\nStore a bunch of group actions (f1, f2, f3, ...). Each action has to return a tuple. The actions are applied in the following sense\n\nf1 is applied on the original solution s\nf2 is applied on s and the results of 1\nf3 is applied on s and the results of 1) and 2)\n\nand so on\n\nExample\n\njulia> f1(s) = (s * s,);\n\njulia> f2(s) = (2s, -s, 5s);\n\njulia> f3(s) = (s + 1,);\n\njulia> GroupActions(f1)(3)\n(3, 9)\n\njulia> GroupActions(f1, f2)(3)\n(3, 9, 6, -3, 15, 18, -9, 45)\n\njulia> GroupActions(f1,f2, f3)(3)\n(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"To help with the more common group actions we provide some helper functions:","category":"page"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"SymmetricGroup","category":"page"},{"location":"monodromy/#HomotopyContinuation.SymmetricGroup","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.SymmetricGroup","text":"SymmetricGroup(n)\n\nGroup action of the symmetric group S(n).\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#Strategies-1","page":"Solving paremeterized systems with monodromy","title":"Strategies","text":"","category":"section"},{"location":"monodromy/#","page":"Solving paremeterized systems with monodromy","title":"Solving paremeterized systems with monodromy","text":"Triangle\nPetal","category":"page"},{"location":"monodromy/#HomotopyContinuation.Triangle","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.Triangle","text":"Triangle(;useweights=true)\n\nA triangle is a loop consisting of the main node and two addtional nodes. If weights is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.Petal","page":"Solving paremeterized systems with monodromy","title":"HomotopyContinuation.Petal","text":"Petal()\n\nA petal is a loop consisting of the main node and one other node connected by two edges with different random weights.\n\n\n\n\n\n","category":"type"},{"location":"sorting/#Sorting-arrays-of-solutions-1","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"We provide functions for sorting analyzing arrays of vectors.","category":"page"},{"location":"sorting/#Computing-unique-points-in-an-array-of-vectors-1","page":"Sorting arrays of solutions","title":"Computing unique points in an array of vectors","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"We provide the unique_points methods to sort through solutions.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"unique_points","category":"page"},{"location":"sorting/#HomotopyContinuation.unique_points","page":"Sorting arrays of solutions","title":"HomotopyContinuation.unique_points","text":"unique_points(points::AbstractVector{<:AbstractVector}; options...)\n\nCompute all unique points with respect to the given options. See UniquePoints for possible options. In particular, it is possible to pass group actions.\n\nExample\n\njulia> pts = [[1.0,0.5], [1.0,0.5], [0.5,1.0]];\njulia> unique_points(pts)\n2-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n [0.5, 1.0]\n\njulia> unique_points(pts; group_action = x -> [x[2],x[1]])\n1-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n\n\n\n\n\n","category":"function"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"The unique_points method is powered by the UniquePoints data structure.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"UniquePoints","category":"page"},{"location":"sorting/#HomotopyContinuation.UniquePoints","page":"Sorting arrays of solutions","title":"HomotopyContinuation.UniquePoints","text":"UniquePoints{V<:AbstractVector, T, F<:Function}\n\nA data structure which holds points of type V where T=real(eltype(V)). This data structure provides an efficient (poly)logarithmic check whether a point already exists where two points u,v are considered equal if F(u,v)<tol, where tol is a tolerance provided through the add! function.\n\nUniquePoints(v::AbstractVector{<:Number}, distance::F)\n\nInitialize the data structure with just one data point v.\n\nUniquePoints(V::Vector{<:AbstractVector{<:Number}}, distance::F; tol=1e-5)\n\nInitialize the data structure with all points in v. These are added in order by add! with the given tolerance tol. In particular, 'UniquePoints' structure will contain only points for which the pairwise distance given by F is less than tol.\n\nUniquePoints(v; kwargs...) = UniquePoints(v, euclidean_distance; kwargs...)\n\nIf F is not specialized, euclidean_distance is used.\n\nOptional keywords:\n\ncheck_real=true adds real from points from group orbits (if they exist). The default is check_real=true.\nThe user can use group_action=foo or, if there is more than one group acting, group_actions=[foo, bar]. Then, points that are in the same group orbit are considered equal. See GroupActions for details regarding the application rules.\n\nExamples\n\njulia> points(UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]]))\n2-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n [0.5, 1.0]\n\njulia> points(UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]], group_action = x -> [x[2],x[1]]))\n1-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n\n\n\n\n\n","category":"type"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"We provide several helper functions for UniquePoints.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"points\nis_contained\nadd!\nsimple_add!\nempty!","category":"page"},{"location":"sorting/#HomotopyContinuation.points","page":"Sorting arrays of solutions","title":"HomotopyContinuation.points","text":"points(data::UniquePoints)\n\nReturn the points stored in data.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.is_contained","page":"Sorting arrays of solutions","title":"HomotopyContinuation.is_contained","text":"is_contained(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nCheck whether x is contained in the data by using the tolerance tol to decide for duplicates.\n\nis_contained(data::UniquePoints{V}, x::V, Val{true}(); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol return the index of the data point which already exists. If the data point is not existing -1 is returned. If data has the option check_real enabled, a -2 will be returned once a real vector was added.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.add!","page":"Sorting arrays of solutions","title":"HomotopyContinuation.add!","text":"add!(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nAdd x to data if it doesn't already exists by using the tolerance tol to decide for duplicates.\n\nadd!(data::UniquePoints{V}, x::V, Val(true); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol to decide for duplicates return the index of the data point which already exists. If the data point is not existing add it to data and return -1. If data has the option check_real enabled, a -2 will be returned once a real vector was added. The element will be the last element of points(data).\n\n\n\n\n\nadd!(node::Node, x; kwargs...)\n\nCalls add! on the points of the Node with option Val(true).\n\n\n\n\n\n","category":"function"},{"location":"sorting/#HomotopyContinuation.simple_add!","page":"Sorting arrays of solutions","title":"HomotopyContinuation.simple_add!","text":"simple_add!(data::UniquePoints{V}, x::V, tol::Real)::Bool\n\nSimilarly to add! but does not apply any group actions. If the data point is not existing add it to data and return -1. Otherwise the index of x in data.points is returned.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#Base.empty!","page":"Sorting arrays of solutions","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(data::UniquePoints)\n\nRemove all points from data.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#Computing-points-in-an-array-of-vectors-which-appear-multiple-times-1","page":"Sorting arrays of solutions","title":"Computing points in an array of vectors which appear multiple times","text":"","category":"section"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"If instead of unique points, the user wants to have the information which points in an array of points appear with multiplicity, they should use the next function.","category":"page"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"multiplicities","category":"page"},{"location":"sorting/#HomotopyContinuation.multiplicities","page":"Sorting arrays of solutions","title":"HomotopyContinuation.multiplicities","text":"multiplicities(vectors; distance=euclidean_distance, tol::Real = 1e-5, kwargs...)\n\nReturns an array of arrays of integers. Each vector w in 'v' contains all indices i,j such that w[i] and w[j] have distance at most tol.\n\nOptional keywords:\n\ncheck_real=true adds real from points from group orbits (if they exist) to the UniquePoints data structure used internally. The default is check_real=false.\nThe user can use group_action=foo or, if there is more than one group acting, group_actions=[foo, bar]. Then, points that are in the same group orbit are considered equal. See GroupActions for details regarding the application rules.\n\njulia> multiplicities([[1,0.5]; [1,0.5]; [1,1]])\n[[1,2]]\n\nThis is the same as\n\nmultiplicities([[1,0.5]; [1,0.5]; [1,1]]; distance=(x,y) -> LinearAlgebra.norm(x-y))\n\nHere is an example for using group actions.\n\njulia> X = [[1, 2, 3, 4], [2,1,3,4], [1,2,4,3], [2,1,4,3]]\njulia> permutation(x) = [x[2], x[1], x[3], x[4]]\njulia> m = multiplicities(X, group_action = permutation)\n[[1,2], [3,4]]\n\n\n\n\n\nmultiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"function"},{"location":"sorting/#","page":"Sorting arrays of solutions","title":"Sorting arrays of solutions","text":"The multiplicities functions may also be applied to Result; see here: multiplicities(::HomotopyContinuation.Results).","category":"page"},{"location":"path_tracker/#Path-Tracker-1","page":"PathTracker","title":"Path Tracker","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"The solve routine is only a very thin wrapper around PathTracker. Therefore you can also use PathTracker directly. This is for example a good choice if you have to solve the same problem many times.","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTracker","page":"PathTracker","title":"HomotopyContinuation.PathTracker","text":" PathTracker{Prob<:AbstractProblem, T, V<:AbstractVector{T}, CT<:CoreTracker}\n\nPathTracker the way to track single paths. It combines the core path tracking routine with an endgame, i.e., it can also deal with singular solutions as well as diverging paths. We call a diverged path a path going to infinity. By convention a path is always tracked from t₁ > 0 towards 0. During the path tracking an approximation of the valuation of a Puiseux series expansion of the solution is computed. This is used to decide whether a path is diverging. To compute singular solutions Cauchy's integral formula is used. There you have to trace out loops around the solution. The number of loops necessary to arrive back at the start point is called the winding number. In order to construct a PathTracker it is recommended to use the pathtracker and pathtracker_startsolutions helper functions. With a PathTracker constructed you can track a single path using the track method. The result of this will be a PathResult.\n\nKeyword arguments\n\nPathTracker is a wrapper around CoreTracker and thus it is possible to set all options which are available for CoreTracker. There are the following PathTracker specific options:\n\nGeneral endgame parameters\n\naccuracy_eg::Float64=min(accuracy, 1e-5)): It is possible to change the accuracy during the path tracking. Usually you want lower the accuracy.\ncond_eg_start::Float64=1e4: The endgame is only started if the condition of the Jacobian is larger than this threshold.\nmax_winding_number::Int=12: This limits the maximal number of loops taken in applying Cauchy's formula.\nmin_cond_at_infinity::Float64=1e7: A path is declared as going to infinity only if it's Jacobian is also larger than this threshold.\nsamples_per_loop::Int=12: To compute singular solutions Cauchy's integral formula is used. The accuracy of the solutions increases with the number of samples per loop.\nt_eg_start::Float64=0.1: The endgame starts only if t is smaller than this threshold.\ntol_val_inf_accurate::Float64=1e-4: A valuation which would result in a path declared as going to infinity is only accepted if the estimated accuracy of the valuation is less than this threshold.\ntol_val_finite_accurate::Float64=1e-3: A valuation which would result in a proper solution is only accepted if the estimated accuracy of the valuation is less than this threshold. This is only affects solutions where the path has at some point near 0 a condition number larger than cond_eg_start.\n\nOverdetermined system specific\n\noverdetermined_min_accuracy=1e-5: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.\noverdetermined_min_residual=1e-3: The minimal residual a singular solution needs to have to be considered a solution of the original system.\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"The easiest way to construct a PathTracker:","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"pathtracker_startsolutions\npathtracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.pathtracker_startsolutions","page":"PathTracker","title":"HomotopyContinuation.pathtracker_startsolutions","text":"pathtracker_startsolutions(args...; kwargs...)\n\nConstruct a PathTracker and start solutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.pathtracker","page":"PathTracker","title":"HomotopyContinuation.pathtracker","text":"pathtracker(args...; kwargs...)\n\nConstruct a PathTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parameterized system f with parameters p from the parameters a to b.\n\ntracker = pathtracker(f, parameters=p, p₁=a, p₀=b)\n\nYou then can obtain a single solution at b by using\n\nx_b = solution(track(tracker, x_a))\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#Methods-1","page":"PathTracker","title":"Methods","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"To track a single path you can use the track and track! methods.","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"track(tracker::PathTracker, x₁, t₁::Float64=1.0; path_number::Int=1, details::Symbol=:default, kwargs...)\ntrack!(tracker::PathTracker, x₁, t₁::Float64=1.0; kwargs...)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.track","page":"PathTracker","title":"HomotopyContinuation.track","text":"track(tracker::PathTracker, x₁, t₁::Float64=1.0; path_number::Int=1, details::Symbol=:default, options...)::PathResult\n\nTrack the path with start solution x₁ from t₁ towards t=0. The details options controls the level of details of the informations available in the PathResult.\n\nPossible values for the options are\n\n\u001daccuracy::Float64\nmax_corrector_iters::Int\nmax_steps::Int\nstart_parameters::AbstractVector\ntarget_parameters::AbstractVector\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.track!","page":"PathTracker","title":"HomotopyContinuation.track!","text":"track!(tracker::PathTracker, x₁, t₁::Float64=1.0; options...)::PathTrackerStatus.states\n\nTrack the path with start solution x₁ from t₁ towards t=0.\n\nPossible values for the options are\n\n\u001daccuracy::Float64\nmax_corrector_iters::Int\nmax_steps::Int\nstart_parameters::AbstractVector\ntarget_parameters::AbstractVector\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"The return type of track! is","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTrackerStatus.states","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTrackerStatus.states","page":"PathTracker","title":"HomotopyContinuation.PathTrackerStatus.states","text":"PathTrackerStatus.states\n\nThe possible return codes the path tracker can return are\n\nPathTrackerStatus.success\nPathTrackerStatus.at_infinity\nPathTrackerStatus.terminated_maximal_iterations\nPathTrackerStatus.terminated_invalid_startvalue\nPathTrackerStatus.terminated_step_size_too_small\nPathTrackerStatus.terminated_singularity\nPathTrackerStatus.terminated_ill_conditioned\nPathTrackerStatus.terminated\nPathTrackerStatus.post_check_failed\nPathTrackerStatus.excess_solution\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"In the case that you track paths of parameter homotopy you can also change the parameters using","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"set_parameters!(::PathTracker)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.set_parameters!-Tuple{PathTracker}","page":"PathTracker","title":"HomotopyContinuation.set_parameters!","text":"set_parameters!(tracker::PathTracker; start_parameters=nothing, target_parameters=nothing)\n\nSet the parameters of a parameter homotopy.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#PathResult-1","page":"PathTracker","title":"PathResult","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"For each path we return a PathResult containing the detailed information about the single path.","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathResult","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathResult","page":"PathTracker","title":"HomotopyContinuation.PathResult","text":"PathResult{V<:AbstractVector}\n\nA PathResult is the result of tracking of a path using PathTracker. Its fields are\n\nreturn_code: One of :success, :at_infinity or any error code in PathTrackerStatus.states converted to a Symbol.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Union{Nothing, Float64}: An approximation of x-x^*₂ where x is the computed solution and x^* is the true solution.\nresidual::Union{Nothing, Float64}: The value of the 2-norm of H(solution, 0).\nmultiplicity::Union{Nothing, Int} is the multiplicity of the solution. This is only assigned by. singular.\ncondition_jacobian::Union{Nothing, Float64}: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.\nwinding_number:Union{Nothing, Int}: The estimated winding number. This is a lower bound on the multiplicity of the solution.\nstart_solution::Union{Nothing, Int}: The start solution of the path.\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nvaluation::Union{Nothing, Vector{Float64}}: An approximation of the valuation of the Puiseux series expansion of x(t).\nvaluation_accuracy::Union{Nothing, Vector{Float64}}: An estimate of the accuracy of the valuation of the Puiseux series expansion of x(t).\nPathResult(tracker::PathTracker, startsolution=nothing, pathnumber::Union{Nothing,Int}=nothing; details=:default)\n\nPossible details values are :minimal (minimal details), :default (default) and :extensive (all information possible).\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"The following helper functions are provided","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"solution\naccuracy(::PathResult)\nmultiplicity\nresidual\nstart_solution\nis_real(::PathResult)\nis_success(::PathResult)\nis_failed\nis_affine\nis_projective\nis_at_infinity\nis_singular\nis_nonsingular","category":"page"},{"location":"path_tracker/#HomotopyContinuation.solution","page":"PathTracker","title":"HomotopyContinuation.solution","text":"solution(pathresult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.accuracy-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation.accuracy","text":"accuracy(pathresult)\n\nGet the accuracy of the solution x of the path, i.e., H(x 0)₂.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.multiplicity","page":"PathTracker","title":"HomotopyContinuation.multiplicity","text":"multiplicity(P::PathResult{T})\n\nReturns the multiplicity of P.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.residual","page":"PathTracker","title":"HomotopyContinuation.residual","text":"residual(pathresult)\n\nGet the residual of the solution x of the path, i.e., H(x 0)₂.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.start_solution","page":"PathTracker","title":"HomotopyContinuation.start_solution","text":"start_solution(pathresult)\n\nGet the start solution of the solution x of the path.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_real-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation.is_real","text":"is_real(pathresult; tol=1e-6)\n\nWe consider a result as real if the 2-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_success-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation.is_success","text":"is_success(pathresult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_failed","page":"PathTracker","title":"HomotopyContinuation.is_failed","text":"is_failed(pathresult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_affine","page":"PathTracker","title":"HomotopyContinuation.is_affine","text":"is_affine(pathresult)\n\nReturn`s true if the solution is an affine vector.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_projective","page":"PathTracker","title":"HomotopyContinuation.is_projective","text":"is_projective(pathresult)\n\nReturn`s true if the solution is a projective vector.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_at_infinity","page":"PathTracker","title":"HomotopyContinuation.is_at_infinity","text":"is_at_infinity(pathresult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_singular","page":"PathTracker","title":"HomotopyContinuation.is_singular","text":"is_singular(pathresult; tol=1e10)\n\nChecks whether the path result is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_nonsingular","page":"PathTracker","title":"HomotopyContinuation.is_nonsingular","text":"is_nonsingular(pathresult; tol=1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Core-Tracker-1","page":"CoreTracker","title":"Core Tracker","text":"","category":"section"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"We also export the path tracking primitive to make the core path tracking routine available for other applications. At the heart is a CoreTracker object which holds all the state.","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"CoreTracker","category":"page"},{"location":"core_tracker/#HomotopyContinuation.CoreTracker","page":"CoreTracker","title":"HomotopyContinuation.CoreTracker","text":"CoreTracker(problem::AbstractProblem, x₁; kwargs...)\n\nConstruct a CoreTracker from the given problem to track elements of type x₁. The path is tracked using a predictor-corrector scheme. The recommended methods to construct a CoreTracker are coretracker and coretracker_startsolutions. Note that a CoreTracker is also a (mutable) iterator.\n\nKeyword arguments\n\naccuracy=1e-7: The accuracy required during the path tracking.\ncorrector::AbstractCorrector: The corrector used during in the predictor-corrector scheme. The default is NewtonCorrector.\ninitial_step_size=0.1: The size of the first step.\nmax_corrector_iters=2: The maximal number of correction steps in a single step.\nmax_lost_digits::Real: The tracking is terminated if we estimate that we loose more than max_lost_digits in the linear algebra steps. This threshold depends on the precision argument.\nmax_refinement_iters=5: The maximal number of correction steps used to refine the final value.\nmax_steps=1_000: The maximal number of iterations the path tracker has available. Note that this changes to 10_000 for parameter homotopies.\nmax_step_size=Inf: The maximal step size.\nmin_step_size=1e-14: The minimal step size.\nprecision::PrecisionOption=PRECISION_FIXED_64: The precision used for evaluating the residual in Newton's method.\npredictor::AbstractPredictor: The predictor used during in the predictor-corrector scheme. The default is Heun()`.\nrefinement_accuracy=1e-8: The precision required for the final value.\nsimple_step_size_alg=false: Use a more simple step size algorithm.\nsteps_jacobian_info_update::Int=1: Every n-th step a linear system will be solved using a QR factorization to obtain an estimate for the condition number of the Jacobian.\nterminate_ill_conditioned::Bool=true: Indicates whether the path tracking should be terminated for ill-conditioned paths. A path is considerd ill-conditioned if the condition number of the Jacobian is larger than ≈1e14 or if it is larger than 1emax_lost_digits.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"The easiest way to construct a CoreTracker:","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"coretracker_startsolutions\ncoretracker","category":"page"},{"location":"core_tracker/#HomotopyContinuation.coretracker_startsolutions","page":"CoreTracker","title":"HomotopyContinuation.coretracker_startsolutions","text":"coretracker_startsolutions(args...; kwargs...)\n\nConstruct a CoreTracker and startsolutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.coretracker","page":"CoreTracker","title":"HomotopyContinuation.coretracker","text":"coretracker(args...; kwargs...)\n\nConstruct a CoreTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions. This is convenient if you want to investigate single paths.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parameterized system f with parameters p from the parameters a to b.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b)\n\nYou then can obtain a single solution at b by using\n\nx_b = track(tracker, x_a).x\n\nTrace a path\n\nTo trace a path you can use the iterator method.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b, max_step_size =0.01)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\nIf we want to guarantee smooth traces we can limit the maximal step size.\n\ntracker = coretracker(f, parameters=p, p₁=a, p₀=b, max_step_size =0.01)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Other-types-1","page":"CoreTracker","title":"Other types","text":"","category":"section"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"CoreTrackerResult\nCoreTrackerStatus.states\nCoreTrackerOptions","category":"page"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerResult","page":"CoreTracker","title":"HomotopyContinuation.CoreTrackerResult","text":" CoreTrackerResult{V<:AbstractVector}\n\nContaining the result of a tracked path. The fields are\n\nreturncode::CoreTrackerStatus.states If the tracking was successfull then it is CoreTrackerStatus.success.\nx::V The result.\nt::ComplexF64 The t when the path tracker stopped.\naccuracy::Float64: The estimated accuracy of x.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerStatus.states","page":"CoreTracker","title":"HomotopyContinuation.CoreTrackerStatus.states","text":"CoreTrackerStatus.states\n\nThe possible states the coretracker can achieve are\n\nCoreTrackerStatus.success\nCoreTrackerStatus.tracking\nCoreTrackerStatus.terminated_maximal_iterations\nCoreTrackerStatus.terminated_invalid_startvalue\nCoreTrackerStatus.terminated_step_size_too_small\nCoreTrackerStatus.terminated_singularity\nCoreTrackerStatus.terminated_ill_conditioned\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerOptions","page":"CoreTracker","title":"HomotopyContinuation.CoreTrackerOptions","text":"CoreTrackerOptions\n\nThe set of options set for a CoreTracker. See the description of CoreTracker for all possible options.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#Methods-1","page":"CoreTracker","title":"Methods","text":"","category":"section"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"To track from a start to an endpoint with the CoreTracker we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"track(tracker::CoreTracker, x₁::AbstractVector, t₁=1.0, t₀=0.0; kwargs...)\ntrack!(x₀, tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0; setup_patch=tracker.options.update_patch, checkstartvalue=true, compute_ẋ=true)\nsetup!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.track","page":"CoreTracker","title":"HomotopyContinuation.track","text":"track(tracker, x₁, t₁=1.0, t₀=0.0; options...)::CoreTrackerResult\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. This returns a CoreTrackerResult. This modifies tracker. See track! for the possible options.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.track!","page":"CoreTracker","title":"HomotopyContinuation.track!","text":" track!(tracker, x₁, t₁=1.0, t₀=0.0; setup_patch=true, checkstartvalue=true, loop::Bool=false)::CoreTrackerResult\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. Returns one of the enum values of CoreTrackerStatus.states indicating the status. If the tracking was successfull it is CoreTrackerStatus.success. If setup_patch is true then setup! is called at the beginning of the tracking.\n\ntrack!(x₀, tracker, x₁, t₁=1.0, t₀=0.0; options...)::CoreTrackerStatus.states\n\nAdditionally also stores the result in x₀ if the tracking was successfull.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.setup!","page":"CoreTracker","title":"HomotopyContinuation.setup!","text":"setup!(::AbstractAffinePatchState, x::AbstractVector)\n\nSetup the affine patch depending on x and modify x if necessary. This is only called once at the beginning of a tracked path.\n\n\n\n\n\nsetup!(cache::AbstractStatefulPredictorCache, H, x, ẋ, t, Jac)\n\nSetup the cache. x is the new path value at t and ẋ is the derivative at t. fac is a factorization of the Jacobian at (x,t). This falls back to calling update.\n\n\n\n\n\nsetup!(coretracker, x₁, t₁=1.0, t₀=0.0, setup_patch=coretracker.options.update_patch, checkstartvalue=true, compute_ẋ=true)\n\nSetup coretracker to track x₁ from t₁ to t₀. Use this if you want to use the coretracker as an iterator.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"It is also possible to use a CoreTracker as an iterator. This can either be done by the high level iterator method or by directly using a CoreTracker as an iterator. The recommend approach is simply using iterator.","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"iterator","category":"page"},{"location":"core_tracker/#HomotopyContinuation.iterator","page":"CoreTracker","title":"HomotopyContinuation.iterator","text":"iterator(tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0; affine=true)\n\nPrepare a tracker to make it usable as a (stateful) iterator. Use this if you want to inspect a specific path. In each iteration the tuple (x,t) is returned. If affine == true then x is the affine solution (internally we compute in projective space).\n\nExample\n\nAssume you have CoreTracker tracker and you wan to track x₁ from 1.0 to 0.25:\n\nfor (x,t) in iterator(tracker, x₁, 1.0, 0.25)\n    println(\"x at t=$t:\")\n    println(x)\nend\n\nNote that this is a stateful iterator. You can still introspect the state of the tracker. For example to check whether the tracker was successfull (and did not terminate early due to some problem) you can do\n\nprintln(\"Success: \", status(tracker) == CoreTrackerStatus.success)\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Introspecting-the-current-state-1","page":"CoreTracker","title":"Introspecting the current state","text":"","category":"section"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"To introspect the current state we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"current_x\ncurrent_t\ncurrent_Δt\niters\nstatus\nLinearAlgebra.cond(::CoreTracker)\ndigits_lost\noptions","category":"page"},{"location":"core_tracker/#HomotopyContinuation.current_x","page":"CoreTracker","title":"HomotopyContinuation.current_x","text":"current_x(tracker::CoreTracker)\n\nReturn the current value of x.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.current_t","page":"CoreTracker","title":"HomotopyContinuation.current_t","text":" current_t(tracker::CoreTracker)\n\nCurrent t.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.current_Δt","page":"CoreTracker","title":"HomotopyContinuation.current_Δt","text":" current_Δt(tracker::CoreTracker)\n\nCurrent step_size Δt.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.iters","page":"CoreTracker","title":"HomotopyContinuation.iters","text":" iters(tracker::CoreTracker)\n\nCurrent number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.status","page":"CoreTracker","title":"HomotopyContinuation.status","text":" status(tracker::CoreTracker)\n\nCurrent status.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#LinearAlgebra.cond-Tuple{CoreTracker}","page":"CoreTracker","title":"LinearAlgebra.cond","text":"LinearAlgebra.cond(tracker::CoreTracker)\n\nReturns the currently computed approximation of the condition number of the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.digits_lost","page":"CoreTracker","title":"HomotopyContinuation.digits_lost","text":"digits_lost(tracker::CoreTracker)\n\nReturns the currently computed approximation of the number of digits lost during the linear system solving in Newton's method.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.options","page":"CoreTracker","title":"HomotopyContinuation.options","text":"options(tracker::CoreTracker)\n\nReturns the options used in the tracker.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Changing-options-1","page":"CoreTracker","title":"Changing options","text":"","category":"section"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"To change settings","category":"page"},{"location":"core_tracker/#","page":"CoreTracker","title":"CoreTracker","text":"accuracy(::CoreTracker)\nset_accuracy!\nmax_corrector_iters\nset_max_corrector_iters!\nmax_step_size\nset_max_step_size!\nmax_refinement_iters\nset_max_refinement_iters!\nrefinement_accuracy\nset_refinement_accuracy!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.accuracy-Tuple{CoreTracker}","page":"CoreTracker","title":"HomotopyContinuation.accuracy","text":" accuracy(tracker::CoreTracker)\n\nCurrent accuracy.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.set_accuracy!","page":"CoreTracker","title":"HomotopyContinuation.set_accuracy!","text":" set_accuracy!(tracker::CoreTracker, accuracy; update_max_lost_digits=true)\n\nSet the current accuracy to accuracy. If update_max_lost_digits is true then the setting max_lost_digits will be updated to the default setting.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_corrector_iters","page":"CoreTracker","title":"HomotopyContinuation.max_corrector_iters","text":" max_corrector_iters(tracker::CoreTracker)\n\nCurrent correction max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_corrector_iters!","page":"CoreTracker","title":"HomotopyContinuation.set_max_corrector_iters!","text":" set_max_corrector_iters!(tracker::CoreTracker, n)\n\nSet the correction max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_step_size","page":"CoreTracker","title":"HomotopyContinuation.max_step_size","text":" max_step_size (tracker::CoreTracker)\n\nCurrent maximal step size.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_step_size!","page":"CoreTracker","title":"HomotopyContinuation.set_max_step_size!","text":" set_max_corrector_iters!(tracker::CoreTracker, Δs)\n\nSet the maximal step size to Δs.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_refinement_iters","page":"CoreTracker","title":"HomotopyContinuation.max_refinement_iters","text":" max_refinement_iters(tracker::CoreTracker)\n\nCurrent refinement max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_refinement_iters!","page":"CoreTracker","title":"HomotopyContinuation.set_max_refinement_iters!","text":" set_max_refinement_iters!(tracker::CoreTracker, n)\n\nSet the current refinement max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.refinement_accuracy","page":"CoreTracker","title":"HomotopyContinuation.refinement_accuracy","text":" refinement_accuracy(tracker::CoreTracker)\n\nCurrent refinement accuracy.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_refinement_accuracy!","page":"CoreTracker","title":"HomotopyContinuation.set_refinement_accuracy!","text":" set_max_refinement_iters!(tracker::CoreTracker, accuracy)\n\nSet the current refinement accuracy to accuracy.\n\n\n\n\n\n","category":"function"},{"location":"newton/#Newton's-method-1","page":"Newton's method","title":"Newton's method","text":"","category":"section"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"Sometimes it is necessary to refine obtained solutions. For this we provide an interface to Newton's method.","category":"page"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"newton\nNewtonResult\nNewtonReturnCode.codes","category":"page"},{"location":"newton/#HomotopyContinuation.newton","page":"Newton's method","title":"HomotopyContinuation.newton","text":"newton(F::AbstractSystem, x₀, norm=euclidean_norm, cache=NewtonCache(F, x₀); tol=1e-6, miniters=1, maxiters=3, simplified_last_step=true)\n\nAn ordinary Newton's method. If simplified_last_step is true, then for the last iteration the previously Jacobian will be used. This uses an LU-factorization for square systems and a QR-factorization for overdetermined.\n\n\n\n\n\n","category":"function"},{"location":"newton/#HomotopyContinuation.NewtonResult","page":"Newton's method","title":"HomotopyContinuation.NewtonResult","text":"NewtonResult{T}\n\nStructure holding information about the outcome of the newton function. The fields are.\n\nreturn_code::NewtonReturnCode.codes: The return code of computation. NewtonReturnCode.converged means that accuracy ≤ tol.\naccuracy::T: |xᵢ-xᵢ₋₁| for i = iters and x₀,x₁,…,xᵢ₋₁,xᵢ are the Newton iterates.\niters::Int: The number of iterations used.\ndigits_lost::Float64 Estimate of the (relative) lost digits in the linear algebra.\n\n\n\n\n\n","category":"type"},{"location":"newton/#HomotopyContinuation.NewtonReturnCode.codes","page":"Newton's method","title":"HomotopyContinuation.NewtonReturnCode.codes","text":"NewtonReturnCode.codes\n\nThe possible return codes of Newton's method\n\nNewtonReturnCode.converged\nNewtonReturnCode.terminated\nNewtonReturnCode.terminated_no_approximate\nNewtonReturnCode.maximal_iterations\n\n\n\n\n\n","category":"type"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"For high performance applications we also provide an in-place version of Newton's method which avoids any temporary allocations.","category":"page"},{"location":"newton/#","page":"Newton's method","title":"Newton's method","text":"newton!\nNewtonCache","category":"page"},{"location":"newton/#HomotopyContinuation.newton!","page":"Newton's method","title":"HomotopyContinuation.newton!","text":"newton!(out, F::AbstractSystem, x₀, norm, cache::AbstractNewtonCache; tol=1e-6, miniters=1, maxiters=3, simplified_last_step=true)\n\nIn-place version of newton. Needs a NewtonCache and norm as input.\n\n\n\n\n\n","category":"function"},{"location":"newton/#HomotopyContinuation.NewtonCache","page":"Newton's method","title":"HomotopyContinuation.NewtonCache","text":"NewtonCache(F::AbstractSystem, x)\n\nCache for the newton function.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Homotopies-1","page":"Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"A homotopy is a function","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"H mathbbC^N  mathbbC  mathbbC^n (xt)  H(xt)","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"where H( t) is a polynomial system for all tmathbbC.","category":"page"},{"location":"homotopies/#Default-homotopies-1","page":"Homotopies","title":"Default homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following homotopies are available by default","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"StraightLineHomotopy\nFixedPointHomotopy\nParameterHomotopy\nCoefficientHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.StraightLineHomotopy","page":"Homotopies","title":"HomotopyContinuation.StraightLineHomotopy","text":"StraightLineHomotopy(G, F; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = γtG(x) + (1-t)F(x).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.FixedPointHomotopy","page":"Homotopies","title":"HomotopyContinuation.FixedPointHomotopy","text":"FixedPointHomotopy(F, x₀; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = (1-t)F(x) + γt(x-x₀).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.ParameterHomotopy","page":"Homotopies","title":"HomotopyContinuation.ParameterHomotopy","text":"ParameterHomotopy(F, parameters;\n    variables=setdiff(MP.variables(F), parameters),\n    p₁=randn(ComplexF64, length(parameters)),\n    p₀=randn(ComplexF64, length(parameters)),\n    γ₁=nothing, γ₀=nothing)\n\nConstruct the homotopy\n\nH(x t) = F(x (tγ₁p₁+(1-t)γ₀p₀)  (tγ₁+(1-t)γ₀))\n\nwhere p₁ and p₀ are a vector of parameter values for F and γ₁ and γ₀ are complex numbers. If γ₁ or γ₀ is nothing, it is assumed that γ₁ and γ₀ are 1. The input parameters specifies the parameter variables of F. Neccessarily, length(parameters) == length(p₁) == length(p₀).\n\nNote that p₁ and p₀ are stored as a tuple p of SVectors and γ₁ and γ₀ are stored as a tuple γ or as γ=nothing\n\nParameterHomotopy(F, parameters;\n    variables=setdiff(MP.variables(F), parameters),\n    start_parameters=randn(ComplexF64, length(parameters)),\n    target_parameters=randn(ComplexF64, length(parameters)),\n    start_gamma=nothing, target_gamma=nothing)\n\nThis is a non-unicode variant where γ₁=start_parameters, γ₀=target_parameters, γ₁=start_gamma, γ₀=target_gamma.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.CoefficientHomotopy","page":"Homotopies","title":"HomotopyContinuation.CoefficientHomotopy","text":"CoefficientHomotopy(support, start_coeffs, target_coeffs)\n\nConstruct the homotopy H(x t) = _a  Aᵢ (c_a t + (1-t)d_a) x^a where c_a are the start coefficients and d_a the target coefficients.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"We also provide more specialised homotopies, which are mostly used internally currently but could be useful in conjunction with the CoreTracker primitive.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"PatchedHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.PatchedHomotopy","page":"Homotopies","title":"HomotopyContinuation.PatchedHomotopy","text":"PatchedHomotopy(H::AbstractHomotopy, patch, v::PVector)\n\nAugment the homotopy H with the given patch v. This results in the system [H(x,t); v ⋅ x - 1]\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Interface-for-custom-homotopies-1","page":"Homotopies","title":"Interface for custom homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The great thing is that you are not limited to the homotopies provided by default. You can define your own homotopy by defining a struct with super type AbstractHomotopy. For this the following interface has to be defined.","category":"page"},{"location":"homotopies/#Types-1","page":"Homotopies","title":"Types","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"AbstractHomotopy\nAbstractHomotopyCache\nHomotopyNullCache","category":"page"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopy","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopy","text":"AbstractHomotopy\n\nRepresenting a homotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopyCache","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopyCache","text":"AbstractHomotopyCache\n\nA cache to avoid allocations for the evaluation of an AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.HomotopyNullCache","page":"Homotopies","title":"HomotopyContinuation.HomotopyNullCache","text":"HomotopyNullCache\n\nThe default AbstractHomotopyCache containing nothing.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Mandatory-1","page":"Homotopies","title":"Mandatory","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following methods are mandatory to implement.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"cache(H::AbstractHomotopy, x, t)\nevaluate!(u, F::AbstractHomotopy, args...)\njacobian!(u, H::AbstractHomotopy, args...)\ndt!\nBase.size(::AbstractHomotopy)","category":"page"},{"location":"homotopies/#HomotopyContinuation.cache-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.cache","text":"cache(H::AbstractHomotopy, x, t)::AbstractHomotopyCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x. The default implementation returns HomotopyNullCache.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt!","page":"Homotopies","title":"HomotopyContinuation.dt!","text":"dt!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#Base.size-Tuple{AbstractHomotopy}","page":"Homotopies","title":"Base.size","text":"Base.size(H::AbstractHomotopy)\n\nReturns a tuple (m, n) indicating that H is a homotopy of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#Optional-1","page":"Homotopies","title":"Optional","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"evaluate_and_jacobian!(u, U, H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate_and_jacobian(H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt!(U, u, H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt(H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate(H::AbstractHomotopy, x, t)\njacobian(H::AbstractHomotopy, x, t)\ndt(H::AbstractHomotopy, x, t)\nbasehomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian!","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t) and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian","text":"evaluate_and_jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt!","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt!","text":"jacobian_and_dt!(U, u, H, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t) and store the results in u (evalution) and v (∂t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt","text":"jacobian_and_dt(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.evaluate","text":"evaluate(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.jacobian","text":"jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.dt","text":"dt(H::AbstractHomotopy, x::AbstractVector, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.basehomotopy","page":"Homotopies","title":"HomotopyContinuation.basehomotopy","text":"basehomotopy(H::AbstractHomotopy)\n\nReturns the 'proper' homotopy describing the problem. Any wrapper homotopy recursively calls wrappedhomotopy with the wrapped homotopy as argument.\n\n\n\n\n\n","category":"function"},{"location":"predictors-correctors/#Predictors-and-Correctors-1","page":"Predictors and correctors","title":"Predictors and Correctors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and correctors","title":"Predictors and correctors","text":"We use a predictor-corrector scheme to track paths. These are the predictors and correctors currently available.","category":"page"},{"location":"predictors-correctors/#Predictors-1","page":"Predictors and correctors","title":"Predictors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and correctors","title":"Predictors and correctors","text":"The following predictors are currently implemented.","category":"page"},{"location":"predictors-correctors/#","page":"Predictors and correctors","title":"Predictors and correctors","text":"Euler\nHeun\nRalston\nRK3\nRK4\nPade21\nNullPredictor","category":"page"},{"location":"predictors-correctors/#HomotopyContinuation.Euler","page":"Predictors and correctors","title":"HomotopyContinuation.Euler","text":"Euler()\n\nThis uses the explicit Euler method for prediction, also known as the tangent predictor.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Heun","page":"Predictors and correctors","title":"HomotopyContinuation.Heun","text":"Heun()\n\nThe Heun predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Ralston","page":"Predictors and correctors","title":"HomotopyContinuation.Ralston","text":"Ralston()\n\nThe Ralston predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.RK3","page":"Predictors and correctors","title":"HomotopyContinuation.RK3","text":"RK3()\n\nThe classical Runge-Kutta predictor of order 3.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.RK4","page":"Predictors and correctors","title":"HomotopyContinuation.RK4","text":"RK4()\n\nThe classical Runge-Kutta predictor of order 4.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.Pade21","page":"Predictors and correctors","title":"HomotopyContinuation.Pade21","text":"Pade21()\n\nThis uses a Padé-approximation of type (2,1) for prediction.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#HomotopyContinuation.NullPredictor","page":"Predictors and correctors","title":"HomotopyContinuation.NullPredictor","text":"NullPredictor()\n\nA predictor which does no prediction step, i.e., it just returns the input as its prediction.\n\n\n\n\n\n","category":"type"},{"location":"predictors-correctors/#Correctors-1","page":"Predictors and correctors","title":"Correctors","text":"","category":"section"},{"location":"predictors-correctors/#","page":"Predictors and correctors","title":"Predictors and correctors","text":"The following correctors are currently implemented.","category":"page"},{"location":"predictors-correctors/#","page":"Predictors and correctors","title":"Predictors and correctors","text":"NewtonCorrector","category":"page"},{"location":"predictors-correctors/#HomotopyContinuation.NewtonCorrector","page":"Predictors and correctors","title":"HomotopyContinuation.NewtonCorrector","text":"NewtonCorrector(;simplified_last_step=true)\n\nAn ordinary Newton's method. If simplified_last_step is true, then for the last iteration the previously Jacobian will be used. This uses an LU-factorization for square systems and a QR-factorization for overdetermined.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Data-structures-for-polynomial-systems-1","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"Polynomial systems can be represented in numerous ways in a computer and each representation has certain tradeoffs. For our purposes the most important thing is that it is fast to evaluate the system. Therefore we automatically convert an input given by DynamicPolynomials to another representation more suitable for numerically evaluations. The default is currently FPSystem.","category":"page"},{"location":"systems/#Default-systems-1","page":"Data structures for polynomial systems","title":"Default systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"We provide the following systems by default.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"FPSystem\nSPSystem\nFixedHomotopy\nFixedParameterSystem\nCompositionSystem","category":"page"},{"location":"systems/#HomotopyContinuation.FPSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FPSystem","text":"FPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a polynomial system using the FixedPolynomials package.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SPSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.SPSystem","text":"SPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a system using the StaticPolynomials package. Note that StaticPolynomials leverages Julias metaprogramming capabilities to automatically generate functions to evaluate the system and its Jacobian. These generated functions are very fast but at the cost of possibly large compile times. The compile time depends on the size of the support of the polynomial system. If you intend to solve a large system or you need to solve a system with the same support but different coefficients even large compile times can be worthwile. As a general rule of thumb this usually is twice as fast as solving the same system using FPSystem.\n\nExample\n\nYou can use SPSystem as follows with solve\n\n@polyvar x y\nF = [x^2+3y^4-2, 2y^2+3x*y+4]\nsolve(F, system=SPSystem)\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedHomotopy","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FixedHomotopy","text":"FixedHomotopy(H, t) <: AbstractSystem\n\nFix a homotopy H(x,t) at t\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedParameterSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.FixedParameterSystem","text":"FixedParameterSystem(F, p) <: AbstractSystem\n\nFix a parameterized system F(x; p) at p, i.e., it is treated as a system without parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.CompositionSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.CompositionSystem","text":"CompositionSystem(composition::Composition, systems_constructor) <: AbstractSystem\n\nA system representing the composition of polynomial maps.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Interface-for-custom-systems-1","page":"Data structures for polynomial systems","title":"Interface for custom systems","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The great thing is that you are not limited to the systems provided by default. Maybe your polynomial system has a particular structure which you want to use to efficiently evaluate it. For this you can define your own homotopy by defining a struct with super type AbstractSystem. For this the following interface has to be defined.","category":"page"},{"location":"systems/#Types-1","page":"Data structures for polynomial systems","title":"Types","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"AbstractSystem\nAbstractSystemCache\nSystemNullCache","category":"page"},{"location":"systems/#HomotopyContinuation.AbstractSystem","page":"Data structures for polynomial systems","title":"HomotopyContinuation.AbstractSystem","text":"AbstractSystem\n\nRepresenting a system of polynomials.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.AbstractSystemCache","page":"Data structures for polynomial systems","title":"HomotopyContinuation.AbstractSystemCache","text":"AbstractSystemCache\n\nA cache to avoid allocations for the evaluation of an AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SystemNullCache","page":"Data structures for polynomial systems","title":"HomotopyContinuation.SystemNullCache","text":"SystemNullCache\n\nAn empty cache if no cache is necessary.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Mandatory-1","page":"Data structures for polynomial systems","title":"Mandatory","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The following methods are mandatory to implement.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"cache(F::AbstractSystem, args...)\nevaluate!(u, F::AbstractSystem, args...)\nevaluate(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\njacobian!(u, F::AbstractSystem, args...)\njacobian(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\nBase.size(::AbstractSystem)","category":"page"},{"location":"systems/#HomotopyContinuation.cache-Tuple{AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.cache","text":"cache(F::AbstractSystem, x)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x.\n\ncache(F::AbstractSystem, x, p)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x and parameters p.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, F::AbstractSystem, x, cache::AbstractSystemCache)\n\nEvaluate the system F at x and store the result in u.\n\nevaluate!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate","text":"evaluate(F::AbstractSystem, x::AbstractVector, cache=cache(F, x))\n\nEvaluate the system F at x.\n\nevaluate(F::AbstractSystem, x::AbstractVector, p, cache=cache(F, x))\n\nEvaluate the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, F::AbstractSystem, x , cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and store the result in u.\n\njacobian!(u, F::AbstractSystem, x , p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.jacobian","page":"Data structures for polynomial systems","title":"HomotopyContinuation.jacobian","text":"jacobian(F::AbstractSystem, x, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x.\n\njacobian(F::AbstractSystem, x , p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Base.size-Tuple{AbstractSystem}","page":"Data structures for polynomial systems","title":"Base.size","text":"Base.size(F::AbstractSystem)\n\nReturns a tuple (m, n) indicating that F is a system of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"Additionally if the system should support parameter homotopies it needs to support","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"differentiate_parameters!\ndifferentiate_parameters","category":"page"},{"location":"systems/#HomotopyContinuation.differentiate_parameters!","page":"Data structures for polynomial systems","title":"HomotopyContinuation.differentiate_parameters!","text":"differentiate_parameters!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.differentiate_parameters","page":"Data structures for polynomial systems","title":"HomotopyContinuation.differentiate_parameters","text":"differentiate_parameters(F::AbstractSystem, x, p, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters\n\n\n\n\n\n","category":"function"},{"location":"systems/#Optional-1","page":"Data structures for polynomial systems","title":"Optional","text":"","category":"section"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"The following methods are mandatory to implement. The following are optional to implement but usually you want to define at least cache.","category":"page"},{"location":"systems/#","page":"Data structures for polynomial systems","title":"Data structures for polynomial systems","text":"evaluate_and_jacobian!(u, U, F::AbstractSystem, x, cache::AbstractSystemCache)\nevaluate_and_jacobian!(u, U, F::AbstractSystem, x, p, cache::AbstractSystemCache)","category":"page"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,AbstractSystemCache}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x , cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,Any,AbstractSystemCache}","page":"Data structures for polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and parameters p and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"norms_distances/#Distances-and-norms-1","page":"Norms and distances","title":"Distances and norms","text":"","category":"section"},{"location":"norms_distances/#","page":"Norms and distances","title":"Norms and distances","text":"We provide functions for computing norms and distances.","category":"page"},{"location":"norms_distances/#","page":"Norms and distances","title":"Norms and distances","text":"euclidean_distance\neuclidean_norm","category":"page"},{"location":"norms_distances/#HomotopyContinuation.euclidean_distance","page":"Norms and distances","title":"HomotopyContinuation.euclidean_distance","text":"euclidean_distance(u, v)\n\nCompute ||u-v||₂.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#HomotopyContinuation.euclidean_norm","page":"Norms and distances","title":"HomotopyContinuation.euclidean_norm","text":"euclidean_norm(u)\n\nCompute ||u||₂.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#","page":"Norms and distances","title":"Norms and distances","text":"infinity_distance\ninfinity_norm","category":"page"},{"location":"norms_distances/#HomotopyContinuation.infinity_distance","page":"Norms and distances","title":"HomotopyContinuation.infinity_distance","text":"infinity_distance(u, v)\n\nCompute the ∞-norm of u-v.\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#HomotopyContinuation.infinity_norm","page":"Norms and distances","title":"HomotopyContinuation.infinity_norm","text":"infinity_norm(z)\n\nCompute the ∞-norm of z. If z is a complex vector this is more efficient than norm(z, Inf).\n\n\n\n\n\n","category":"function"},{"location":"norms_distances/#","page":"Norms and distances","title":"Norms and distances","text":"fubini_study","category":"page"},{"location":"norms_distances/#HomotopyContinuation.fubini_study","page":"Norms and distances","title":"HomotopyContinuation.fubini_study","text":"fubini_study(x::PVector, y::PVector)\n\nComputes the Fubini-Study distance between x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Input-1","page":"Reference","title":"Input","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We support any polynomials which follow the MultivariatePolynomials interface. By default we export the routines @polyvar, PolyVar, differentiate and variables from the DynamicPolynomials implementation. With these you can simply create variables","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"# Create variables x, y, z\n@polyvar x y z\nf = x^2+y^2+z^2\n\n# You can also create an array of variables\n@polyvar x[1:3] # This creates x1, x2, x3 accessed by x[1], x[2], x[3]\nf = dot(x, x) # = x[1]^2+x[2]^2+x[3]^2\n\n# Also you can create matrices of variables\n# This creates x1_1, x1_2, x2_1, x2_2 accessed by\n# x[1,1], x[1,2], x[2,1], x[2,2]\n@polyvar x[1:2, 1:2]","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We also provide methods construct compositions of polynomial systems:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"compose","category":"page"},{"location":"reference/#HomotopyContinuation.compose","page":"Reference","title":"HomotopyContinuation.compose","text":"compose(g, f)::Composition\n\nCompose the polynomial systems g and f. You can also use the infix operator ∘ (written by \\circ).\n\njulia> @polyvar a b c x y z;\njulia> g = [a * b * c];\njulia> f = [x+y, y + z, x + z];\njulia> expand(compose(g, f))\n1-element Array{DynamicPolynomials.Polynomial{true,Int64},1}:\n x²y + x²z + xy² + 2xyz + xz² + y²z + yz²\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities-1","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"is_homogeneous\nuniquevar\nhomogenize","category":"page"},{"location":"reference/#HomotopyContinuation.is_homogeneous","page":"Reference","title":"HomotopyContinuation.is_homogeneous","text":"is_homogeneous(f::MP.AbstractPolynomialLike)\n\nChecks whether f is homogeneous.\n\nis_homogeneous(f::MP.AbstractPolynomialLike, vars)\n\nChecks whether f is homogeneous in the variables vars with possible weights.\n\n\n\n\n\nis_homogeneous(F::Vector{MP.AbstractPolynomialLike}, variables)\n\nChecks whether each polynomial in F is homogeneous in the variables variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.uniquevar","page":"Reference","title":"HomotopyContinuation.uniquevar","text":"uniquevar(f::MP.AbstractPolynomialLike, tag=:x0)\nuniquevar(F::MPPolys, tag=:x0)\n\nCreates a unique variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.homogenize","page":"Reference","title":"HomotopyContinuation.homogenize","text":"homogenize(f::MP.AbstractPolynomial, variable=uniquevar(f))\n\nHomogenize the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, variable=uniquevar(F))\n\nHomogenize each polynomial in F by using the given variable variable.\n\nhomogenize(f::MP.AbstractPolynomial, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(f))\n\nHomogenize the variables v in the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(F))\n\nHomogenize the variables v in each polynomial in F by using the given variable variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AffinePatches-1","page":"Reference","title":"AffinePatches","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Affine patches are there to augment projective system such that they can be considered as (locally) affine system. By default the following patches are defined","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"OrthogonalPatch\nEmbeddingPatch\nRandomPatch\nFixedPatch","category":"page"},{"location":"reference/#HomotopyContinuation.OrthogonalPatch","page":"Reference","title":"HomotopyContinuation.OrthogonalPatch","text":"OrthogonalPatch()\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.EmbeddingPatch","page":"Reference","title":"HomotopyContinuation.EmbeddingPatch","text":"EmbeddingPatch()\n\nHolds an PVector onto its affine patch. With this the effect is basically the same as tracking in affine space.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.RandomPatch","page":"Reference","title":"HomotopyContinuation.RandomPatch","text":"RandomPatch()\n\nA random patch. The vector has norm 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.FixedPatch","page":"Reference","title":"HomotopyContinuation.FixedPatch","text":"FixedPatch()\n\n\n\n\n\n","category":"type"}]
}
